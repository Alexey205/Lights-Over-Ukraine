<!DOCTYPE html>
<html lang="uk">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lights Over Ukraine</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="icon" href="src/icon.png" type="image/png">
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
        }

        #map {
            height: 100vh;
            width: 100vw;
        }

        .progress-container {
            width: 60px;
            height: 6px;
            background-color: rgba(100, 100, 100, 0.4);
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background-color: #4caf50;
        }

        .health-container {
            width: 60px;
            height: 6px;
            background-color: rgba(100, 100, 100, 0.4);
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }

        .health-bar {
            transition: width 0.1s linear;
            height: 100%;
            width: 100%;
            background-color: rgba(244, 67, 54, 0.7);
        }

        .status-working {
            color: green;
        }

        .status-damaged {
            color: red;
        }

        .tooltip-hidden .leaflet-tooltip {
            display: none;
        }

        #teamsStatus {
            font-weight: bold;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #ddd;
        }

        .warning-message {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-family: sans-serif;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            animation: highlight 0.5s ease 2;
            animation-delay: 1s;
        }

        .warning-message.good-news {
            background: rgba(76, 175, 80, 0.9);
            /* –ó–µ–ª–µ–Ω–∏–π –∫–æ–ª—ñ—Ä */
            animation: highlight-green 0.5s ease 2;
            animation-delay: 1s;
        }

        .warning-message.bad-news {
            background: rgba(255, 87, 34, 0.9);
            /* –ü–æ—Ç–æ—á–Ω–∏–π –ø–æ–º–∞—Ä–∞–Ω—á–µ–≤–∏–π */
            animation: highlight 0.5s ease 2;
            animation-delay: 1s;
        }

        @keyframes highlight-green {
            0% {
                transform: translateX(-50%) scale(1);
            }

            50% {
                transform: translateX(-50%) scale(1.1);
            }

            100% {
                transform: translateX(-50%) scale(1);
            }
        }

        @keyframes highlight {
            0% {
                transform: translateX(-50%) scale(1);
            }

            50% {
                transform: translateX(-50%) scale(1.1);
            }

            100% {
                transform: translateX(-50%) scale(1);
            }
        }


        @keyframes fadeOut {
            to {
                opacity: 0;
                top: 10px;
            }
        }

        .city-disabled {
            background: radial-gradient(circle, rgba(120, 120, 120, 1) 0%, rgba(120, 120, 120, 0.8) 50%, rgba(120, 120, 120, 0) 100%);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            position: absolute;
            top: -8px;
            left: -8px;
            z-index: -1;
        }

        .leaflet-tooltip {
            font-size: 14px;
            white-space: nowrap;
        }

        .power-info {
            font-size: 12px;
            color: #555;
            margin-top: 3px;
        }

        #upgradesPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 14px;
            border-radius: 10px;
            font-family: sans-serif;
            font-size: 14px;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            line-height: 1.4;
            width: 300px;
        }

        #upgradesPanel button {
            display: block;
            width: 100%;
            margin: 8px 0;
            padding: 8px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: #f8f8f8;
            text-align: left;
            transition: background 0.2s;
        }

        #upgradesPanel button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        #upgradesPanel button:hover {
            background: #e8e8e8;
        }

        #incomeRate {
            color: #2E7D32;
            font-weight: bold;
        }

        .panel-toggle {
            position: absolute;
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 1002;
            font-size: 16px;
            line-height: 1;
            padding: 0;
            border: none;
        }

        .panel-toggle:hover {
            background: #f0f0f0;
        }

        #toggleUpgradesPanel {
            top: 10px;
            right: 10px;
        }

        #toggleStatusPanel {
            bottom: 10px;
            left: 10px;
        }

        .hidden {
            display: none !important;
        }

        #upgradesPanel,
        #statusPanel {
            transition: transform 0.3s ease-in-out;
        }

        #upgradesPanel.collapsed {
            transform: translateX(calc(100% + 10px));
            /* –î–æ–¥–∞—î–º–æ —â–µ 10px –∑–∞ –º–µ–∂—ñ –µ–∫—Ä–∞–Ω—É */
        }

        #statusPanel.collapsed {
            transform: translateX(calc(-100% - 10px));
            /* –î–æ–¥–∞—î–º–æ —â–µ 10px –∑–∞ –º–µ–∂—ñ –µ–∫—Ä–∞–Ω—É */
        }

        #lives-container {
            position: absolute;
            top: 15px;
            left: 4vw;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .life {
            font-size: 24px;
            color: #ff5252;
        }

        #game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
            font-family: sans-serif;
        }

        #game-over h2 {
            font-size: 36px;
            margin-bottom: 20px;
        }

        #restart-button {
            padding: 12px 24px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        #restart-button:hover {
            background: #45a049;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <div id="toggleUpgradesPanel" class="panel-toggle">‚öôÔ∏è</div>
    <div id="toggleStatusPanel" class="panel-toggle">‚ÑπÔ∏è</div>
    <div id="statusPanel" style="
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px 14px;
        border-radius: 10px;
        font-family: sans-serif;
        font-size: 14px;
        box-shadow: 0 0 8px rgba(0,0,0,0.2);
        z-index: 1000;
        line-height: 1.4;
        width: 300px;
    "></div>

    <div id="upgradesPanel">
        <h3 style="margin-top: 0;">–†–µ—Å—É—Ä—Å–∏: <span id="energyResources">0</span> –ú–í—Ç¬∑–≥–æ–¥ (<span id="incomeRate">0</span>
            –ú–í—Ç/—Ö–≤)</h3>
        <button onclick="buyUpgrade('team')">+1 –ë—Ä–∏–≥–∞–¥–∞ (100 –ú–í—Ç¬∑–≥–æ–¥) ‚Üí +50 –ú–í—Ç –≤–∏—Ç—Ä–∞—Ç</button>
        <button onclick="buyUpgrade('powerPlant')">–ü–æ–∫—Ä–∞—â–∏—Ç–∏ –≤–∏–ø–∞–¥–∫–æ–≤—É —Å—Ç–∞–Ω—Ü—ñ—é (300 –ú–í—Ç¬∑–≥–æ–¥) ‚Üí +200 –ú–í—Ç</button>
        <button onclick="buyLineUpgrade()" id="lineUpgradeBtn">
            –ü–æ–∫—Ä–∞—â–∏—Ç–∏ –ª—ñ–Ω—ñ—ó (200 –ú–í—Ç¬∑–≥–æ–¥) ‚Üí –†—ñ–≤–µ–Ω—å 1/3
        </button>
        <button onclick="buyAutoRepair()" id="autoRepairBtn">
            –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π —Ä–µ–º–æ–Ω—Ç (800 –ú–í—Ç¬∑–≥–æ–¥)
        </button>
    </div>

    <!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∂–∏—Ç—Ç—ñ–≤ -->
    <div id="lives-container">
        <span class="life">‚ù§Ô∏è</span>
        <span class="life">‚ù§Ô∏è</span>
        <span class="life">‚ù§Ô∏è</span>
    </div>

    <!-- –ï–∫—Ä–∞–Ω –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –≥—Ä–∏ -->
    <div id="game-over">
        <h2>–ì—Ä—É –∑–∞–≤–µ—Ä—à–µ–Ω–æ!</h2>
        <p>–í–∏ –≤–∏—Ç—Ä–∞—Ç–∏–ª–∏ –≤—Å—ñ –∂–∏—Ç—Ç—è</p>
        <button id="restart-button">–ì—Ä–∞—Ç–∏ –∑–Ω–æ–≤—É</button>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        const map = L.map('map').setView([48.5, 31], 6);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        const cities = {
            '–ö–∏—ó–≤': { coords: [50.45, 30.52], powerNeed: 1500 },
            '–õ—å–≤—ñ–≤': { coords: [49.84, 24.03], powerNeed: 800 },
            '–•–∞—Ä–∫—ñ–≤': { coords: [49.99, 36.23], powerNeed: 1200 },
            '–û–¥–µ—Å–∞': { coords: [46.48, 30.73], powerNeed: 900 },
            '–î–Ω—ñ–ø—Ä–æ': { coords: [48.45, 34.98], powerNeed: 1100 },
            '–ó–∞–ø–æ—Ä—ñ–∂–∂—è': { coords: [47.84, 35.14], powerNeed: 700 },
            '–õ—É—Ü—å–∫': { coords: [50.75, 25.33], powerNeed: 400 },
            '–Ü–≤–∞–Ω–æ-–§—Ä–∞–Ω–∫—ñ–≤—Å—å–∫': { coords: [48.92, 24.71], powerNeed: 450 },
            '–¢–µ—Ä–Ω–æ–ø—ñ–ª—å': { coords: [49.55, 25.59], powerNeed: 350 },
            '–†—ñ–≤–Ω–µ': { coords: [50.62, 26.25], powerNeed: 300 },
            '–ß–µ—Ä–Ω—ñ–≤—Ü—ñ': { coords: [48.29, 25.94], powerNeed: 400 },
            '–í—ñ–Ω–Ω–∏—Ü—è': { coords: [49.23, 28.48], powerNeed: 500 },
            '–ñ–∏—Ç–æ–º–∏—Ä': { coords: [50.25, 28.66], powerNeed: 400 },
            '–ü–æ–ª—Ç–∞–≤–∞': { coords: [49.59, 34.55], powerNeed: 600 },
            '–ö—Ä–æ–ø–∏–≤–Ω–∏—Ü—å–∫–∏–π': { coords: [48.51, 32.26], powerNeed: 450 },
            '–ú–∏–∫–æ–ª–∞—ó–≤': { coords: [46.97, 31.99], powerNeed: 550 },
            '–•–µ—Ä—Å–æ–Ω': { coords: [46.63, 32.6], powerNeed: 500 },
            '–ß–µ—Ä–Ω—ñ–≥—ñ–≤': { coords: [51.5, 31.3], powerNeed: 450 },
            '–°—É–º–∏': { coords: [50.92, 34.78], powerNeed: 400 },
            '–£–∂–≥–æ—Ä–æ–¥': { coords: [48.62, 22.3], powerNeed: 350 },
            '–ß–µ—Ä–∫–∞—Å–∏': { coords: [49.44, 32.06], powerNeed: 400 },
            '–•–º–µ–ª—å–Ω–∏—Ü—å–∫–∏–π': { coords: [49.42, 27.0], powerNeed: 450 },
            '–ö—Ä–∞–º–∞—Ç–æ—Ä—Å—å–∫': { coords: [48.74, 37.58], powerNeed: 300 },
            '–ú–∞—Ä—ñ—É–ø–æ–ª—å': { coords: [47.1, 37.55], powerNeed: 600 },
            '–°—ñ–º—Ñ–µ—Ä–æ–ø–æ–ª—å': { coords: [44.95, 34.1], powerNeed: 700 },
            '–°–µ–≤–∞—Å—Ç–æ–ø–æ–ª—å': { coords: [44.61, 33.53], powerNeed: 500 },
            '–ú–µ–ª—ñ—Ç–æ–ø–æ–ª—å': { coords: [46.85, 35.37], powerNeed: 250 },
            '–õ—É–≥–∞–Ω—Å—å–∫': { coords: [48.57, 39.32], powerNeed: 400 },
            '–ö–µ—Ä—á': { coords: [45.35, 36.47], powerNeed: 200 },
            '–ù—ñ–∫–æ–ø–æ–ª—å': { coords: [47.57, 34.4], powerNeed: 300 },
            '–ë—ñ–ª–∞ –¶–µ—Ä–∫–≤–∞': { coords: [49.8, 30.12], powerNeed: 200 },
            '–ö—Ä–µ–º–µ–Ω—á—É–∫': { coords: [49.07, 33.42], powerNeed: 350 },
            '–ö—Ä–∏–≤–∏–π –†—ñ–≥': { coords: [47.91, 33.39], powerNeed: 800 }
        };

        const powerStations = [
            { name: '–ë—É—Ä—à—Ç–∏–Ω—Å—å–∫–∞ –¢–ï–°', coords: [49.26, 24.63], type: '–¢–ï–°', powerOutput: 2800 },
            { name: '–ü—ñ–≤–¥–µ–Ω–Ω–æ—É–∫—Ä–∞—ó–Ω—Å—å–∫–∞ –ê–ï–°', coords: [47.82, 31.18], type: '–ê–ï–°', powerOutput: 3500 },
            { name: '–•–º–µ–ª—å–Ω–∏—Ü—å–∫–∞ –ê–ï–°', coords: [50.37, 26.64], type: '–ê–ï–°', powerOutput: 2500 },
            { name: '–ö–∏—ó–≤—Å—å–∫–∞ –ì–ï–°', coords: [50.58, 30.5], type: '–ì–ï–°', powerOutput: 500 },
            { name: '–ó–∞–ø–æ—Ä—ñ–∑—å–∫–∞ –ê–ï–°', coords: [47.51, 34.58], type: '–ê–ï–°', powerOutput: 6500 },
            { name: '–¢—Ä–∏–ø—ñ–ª—å—Å—å–∫–∞ –¢–ï–°', coords: [50.13, 30.79], type: '–¢–ï–°', powerOutput: 2200 },
            { name: '–ö—Ä–∏–≤–æ—Ä—ñ–∑—å–∫–∞ –¢–ï–°', coords: [47.98, 33.38], type: '–¢–ï–°', powerOutput: 1600 },
            { name: '–ö—Ä–µ–º–µ–Ω—á—É—Ü—å–∫–∞ –ì–ï–°', coords: [49.10, 33.42], type: '–ì–ï–°', powerOutput: 450 },
            { name: '–ë–æ—Ç–∏—î–≤—Å—å–∫–∞ –í–ï–°', coords: [46.85, 36.0], type: '–í–ï–°', powerOutput: 400 }
        ];

        const connections = [
            ['–ö–∏—ó–≤', '–ñ–∏—Ç–æ–º–∏—Ä'], ['–ë–æ—Ç–∏—î–≤—Å—å–∫–∞ –í–ï–°', '–ó–∞–ø–æ—Ä—ñ–∂–∂—è'], ['–ñ–∏—Ç–æ–º–∏—Ä', '–†—ñ–≤–Ω–µ'], ['–†—ñ–≤–Ω–µ', '–õ—É—Ü—å–∫'], ['–õ—É—Ü—å–∫', '–õ—å–≤—ñ–≤'],
            ['–ö–∏—ó–≤', '–ß–µ—Ä–Ω—ñ–≥—ñ–≤'], ['–ö–∏—ó–≤', '–ß–µ—Ä–∫–∞—Å–∏'], ['–ö–∏—ó–≤', '–ü–æ–ª—Ç–∞–≤–∞'], ['–ö–∏—ó–≤', '–¢—Ä–∏–ø—ñ–ª—å—Å—å–∫–∞ –¢–ï–°'],
            ['–ü–æ–ª—Ç–∞–≤–∞', '–•–∞—Ä–∫—ñ–≤'], ['–ü–æ–ª—Ç–∞–≤–∞', '–ö—Ä–∞–º–∞—Ç–æ—Ä—Å—å–∫'], ['–ö—Ä–∞–º–∞—Ç–æ—Ä—Å—å–∫', '–ú–∞—Ä—ñ—É–ø–æ–ª—å'],
            ['–ö—Ä–∞–º–∞—Ç–æ—Ä—Å—å–∫', '–î–Ω—ñ–ø—Ä–æ'], ['–î–Ω—ñ–ø—Ä–æ', '–ó–∞–ø–æ—Ä—ñ–∂–∂—è'], ['–î–Ω—ñ–ø—Ä–æ', '–ö—Ä–∏–≤–æ—Ä—ñ–∑—å–∫–∞ –¢–ï–°'],
            ['–î–Ω—ñ–ø—Ä–æ', '–ö—Ä–æ–ø–∏–≤–Ω–∏—Ü—å–∫–∏–π'], ['–ö—Ä–æ–ø–∏–≤–Ω–∏—Ü—å–∫–∏–π', '–ß–µ—Ä–∫–∞—Å–∏'], ['–ö—Ä–æ–ø–∏–≤–Ω–∏—Ü—å–∫–∏–π', '–ú–∏–∫–æ–ª–∞—ó–≤'],
            ['–ú–∏–∫–æ–ª–∞—ó–≤', '–û–¥–µ—Å–∞'], ['–ú–∏–∫–æ–ª–∞—ó–≤', '–•–µ—Ä—Å–æ–Ω'], ['–•–µ—Ä—Å–æ–Ω', '–°—ñ–º—Ñ–µ—Ä–æ–ø–æ–ª—å'],
            ['–°—ñ–º—Ñ–µ—Ä–æ–ø–æ–ª—å', '–°–µ–≤–∞—Å—Ç–æ–ø–æ–ª—å'], ['–í—ñ–Ω–Ω–∏—Ü—è', '–ö–∏—ó–≤'], ['–í—ñ–Ω–Ω–∏—Ü—è', '–•–º–µ–ª—å–Ω–∏—Ü—å–∫–∏–π'],
            ['–•–º–µ–ª—å–Ω–∏—Ü—å–∫–∏–π', '–¢–µ—Ä–Ω–æ–ø—ñ–ª—å'], ['–¢–µ—Ä–Ω–æ–ø—ñ–ª—å', '–Ü–≤–∞–Ω–æ-–§—Ä–∞–Ω–∫—ñ–≤—Å—å–∫'],
            ['–Ü–≤–∞–Ω–æ-–§—Ä–∞–Ω–∫—ñ–≤—Å—å–∫', '–ß–µ—Ä–Ω—ñ–≤—Ü—ñ'], ['–£–∂–≥–æ—Ä–æ–¥', '–Ü–≤–∞–Ω–æ-–§—Ä–∞–Ω–∫—ñ–≤—Å—å–∫'],
            ['–°—É–º–∏', '–•–∞—Ä–∫—ñ–≤'], ['–°—É–º–∏', '–ß–µ—Ä–Ω—ñ–≥—ñ–≤'],
            ['–ü—ñ–≤–¥–µ–Ω–Ω–æ—É–∫—Ä–∞—ó–Ω—Å—å–∫–∞ –ê–ï–°', '–ú–∏–∫–æ–ª–∞—ó–≤'],
            ['–ö–∏—ó–≤—Å—å–∫–∞ –ì–ï–°', '–ö–∏—ó–≤'], ['–ö—Ä–µ–º–µ–Ω—á—É—Ü—å–∫–∞ –ì–ï–°', '–ö—Ä–µ–º–µ–Ω—á—É–∫'], ['–ö—Ä–∏–≤–æ—Ä—ñ–∑—å–∫–∞ –¢–ï–°', '–ö—Ä–∏–≤–∏–π –†—ñ–≥'],
            ['–¢—Ä–∏–ø—ñ–ª—å—Å—å–∫–∞ –¢–ï–°', '–ë—ñ–ª–∞ –¶–µ—Ä–∫–≤–∞'], ['–ó–∞–ø–æ—Ä—ñ–∑—å–∫–∞ –ê–ï–°', '–ó–∞–ø–æ—Ä—ñ–∂–∂—è'],
            ['–ú–µ–ª—ñ—Ç–æ–ø–æ–ª—å', '–ó–∞–ø–æ—Ä—ñ–∂–∂—è'], ['–õ—É–≥–∞–Ω—Å—å–∫', '–ö—Ä–∞–º–∞—Ç–æ—Ä—Å—å–∫'],
            ['–ö–µ—Ä—á', '–°—ñ–º—Ñ–µ—Ä–æ–ø–æ–ª—å'], ['–ù—ñ–∫–æ–ø–æ–ª—å', '–ó–∞–ø–æ—Ä—ñ–∂–∂—è'], ['–ë—ñ–ª–∞ –¶–µ—Ä–∫–≤–∞', '–ö–∏—ó–≤'], ['–ö—Ä–µ–º–µ–Ω—á—É–∫', '–ü–æ–ª—Ç–∞–≤–∞'],
            ['–ë—É—Ä—à—Ç–∏–Ω—Å—å–∫–∞ –¢–ï–°', '–Ü–≤–∞–Ω–æ-–§—Ä–∞–Ω–∫—ñ–≤—Å—å–∫'],
            ['–•–º–µ–ª—å–Ω–∏—Ü—å–∫–∞ –ê–ï–°', '–†—ñ–≤–Ω–µ'],
            ['–í—ñ–Ω–Ω–∏—Ü—è', '–ö—Ä–æ–ø–∏–≤–Ω–∏—Ü—å–∫–∏–π']
        ];

        const cityMarkers = {};
        const lineLayers = [];
        const powerStationMarkers = {};
        const cityHealth = {};
        const cityHealthMarkers = {};
        const cityDisabledLayers = {};
        let repairTeams = 3;
        let difficultyMultiplier = 1;
        let lastAttackTime = Date.now();
        let gameStartTime = Date.now();
        let energyResources = 0;
        const efficiencyFactor = 0.05;
        let isGameRunning = true;
        let resourceUpdateCooldown = false;
        let currentIncomeRate = 0; // –ü–æ—Ç–æ—á–Ω–∏–π –¥–æ—Ö—ñ–¥ –≤ –ú–í—Ç¬∑–≥–æ–¥/—Ö–≤
        let balanceUpdateInterval; // –Ü–Ω—Ç–µ—Ä–≤–∞–ª –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –±–∞–ª–∞–Ω—Å—É
        let lives = 3;
        const maxLives = 3;
        let isGameOver = false;
        let attackTimeout;

        const repairTimes = {
            '–ê–ï–°': 8000,
            '–¢–ï–°': 5000,
            '–ì–ï–°': 4000,
            '–í–ï–°': 3000,
            'line': 2000
        };

        const upgrades = {
            team: {
                cost: 100,
                effect: () => {
                    repairTeams++;
                    const perCityIncrease = 50 / Object.keys(cities).length;
                    for (const city in cities) {
                        cities[city].powerNeed += perCityIncrease;
                    }
                }
            },
            powerPlant: {
                cost: 300,
                effect: () => {
                    // –û—Ç—Ä–∏–º—É—î–º–æ –≤—Å—ñ —Å—Ç–∞–Ω—Ü—ñ—ó, –∫—Ä—ñ–º –ê–ï–°
                    const stationNames = Object.keys(powerStationMarkers)
                        .filter(name => powerStationMarkers[name].type !== '–ê–ï–°');

                    if (stationNames.length === 0) {
                        showWarning("–ù–µ–º–∞—î –¥–æ—Å—Ç—É–ø–Ω–∏—Ö —Å—Ç–∞–Ω—Ü—ñ–π –¥–ª—è –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è!", false);
                        return null;
                    }
                    const name = stationNames[Math.floor(Math.random() * stationNames.length)];
                    powerStationMarkers[name].powerOutput += 200;

                    // –û–Ω–æ–≤–ª—é—î–º–æ –ø—ñ–¥–∫–∞–∑–∫—É
                    updatePowerStationTooltip(name);

                    return name;
                }
            }
        };

        const lineUpgrades = {
            level: 0,
            maxLevel: 3,
            levels: ["–ë–∞–∑–æ–≤—ñ", "–£–∫—Ä—ñ–ø–ª–µ–Ω—ñ", "–ù–∞–¥—ñ–π–Ω—ñ", "–Ü–¥–µ–∞–ª—å–Ω—ñ"],
            damageChances: [0.7, 0.55, 0.4, 0.25],
            repairTimes: [1.0, 0.85, 0.7, 0.55],
            costs: [0, 300, 500, 700],
            colors: ['#888', '#007BFF', '#4CAF50', '#FFD700'],
            weights: [2, 3, 4, 5],
            autoRepair: {
                unlocked: false,
                active: false,
                cost: 800,
                repairSpeed: 0.5
            }
        };

        // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–æ—Ö–æ–¥—É –≤ —Ä–µ–∞–ª—å–Ω–æ–º—É —á–∞—Å—ñ
        function updateIncomeRate() {
            const { stats } = calculatePowerDistribution();
            const currentSurplus = stats.totalProduction - stats.totalConsumption;

            if (currentSurplus > 0) {
                // –ó–º–µ–Ω—à—É—î–º–æ –¥–æ—Ö—ñ–¥ —É 5 —Ä–∞–∑—ñ–≤ (0.01 –∑–∞–º—ñ—Å—Ç—å 0.05)
                currentIncomeRate = Math.floor(currentSurplus * 0.01 * 60); // 1% –≤—ñ–¥ –ø—Ä–æ—Ñ—ñ—Ü–∏—Ç—É –≤ —Å–µ–∫—É–Ω–¥—É * 60
            } else {
                currentIncomeRate = 0;
            }

            document.getElementById("incomeRate").textContent = currentIncomeRate;
        }

        // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –±–∞–ª–∞–Ω—Å—É –∫–æ–∂–Ω—É —Å–µ–∫—É–Ω–¥—É
        function updateBalancePeriodically() {
            if (currentIncomeRate > 0) {
                // –î–æ–¥–∞—î–º–æ —Ä–µ—Å—É—Ä—Å–∏ (1/60 –≤—ñ–¥ —Ö–≤–∏–ª–∏–Ω–Ω–æ–≥–æ –¥–æ—Ö–æ–¥—É –∑–∞ —Å–µ–∫—É–Ω–¥—É)
                energyResources += currentIncomeRate / 60;
                updateResourceUI();
            }
        }

        function buyLineUpgrade() {
            if (lineUpgrades.level >= lineUpgrades.maxLevel) {
                showWarning("–õ—ñ–Ω—ñ—ó –≤–∂–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø–æ–∫—Ä–∞—â–µ–Ω—ñ!", false);
                return;
            }

            const next = lineUpgrades.level + 1;
            const cost = lineUpgrades.costs[next];

            if (energyResources >= cost) {
                energyResources -= cost;
                lineUpgrades.level = next;
                updateResourceUI();

                lineLayers.forEach(conn => {
                    conn.line.setStyle({
                        color: lineUpgrades.colors[next],
                        weight: lineUpgrades.weights[next]
                    });
                });

                updateUpgradeButtons();
                updateIncomeRate();
                showWarning(`–õ—ñ–Ω—ñ—ó –ø–æ–∫—Ä–∞—â–µ–Ω–æ –¥–æ —Ä—ñ–≤–Ω—è "${lineUpgrades.levels[next]}"`, true);
            } else {
                showWarning(`–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ä–µ—Å—É—Ä—Å—ñ–≤! –ü–æ—Ç—Ä—ñ–±–Ω–æ ${cost} –ú–í—Ç¬∑–≥–æ–¥`, false);
            }
        }

        function createTooltipContent(name, powerInfo) {
            // –î–ª—è –µ–ª–µ–∫—Ç—Ä–æ—Å—Ç–∞–Ω—Ü—ñ–π
            if (powerStationMarkers[name]) {
                const ps = powerStationMarkers[name];
                return `<b>${name} (${ps.type})</b><div class="power-info">–ü–æ—Ç—É–∂–Ω—ñ—Å—Ç—å: ${ps.powerOutput} –ú–í—Ç</div>`;
            }
            // –î–ª—è –º—ñ—Å—Ç
            return `<b>${name}</b><div class="power-info">${powerInfo}</div>`;
        }

        function updatePowerStationTooltip(stationName) {
            const ps = powerStationMarkers[stationName];
            if (!ps) return;

            const newContent = createTooltipContent(
                stationName,
                `–ü–æ—Ç—É–∂–Ω—ñ—Å—Ç—å: ${ps.powerOutput} –ú–í—Ç`
            );

            // –û–Ω–æ–≤–ª—é—î–º–æ –ø—ñ–¥–∫–∞–∑–∫—É, —è–∫—â–æ –≤–æ–Ω–∞ –≤—ñ–¥–∫—Ä–∏—Ç–∞
            const tooltip = ps.marker.getTooltip();
            if (tooltip && tooltip.isOpen()) {
                ps.marker.setTooltipContent(newContent);
            }

            // –û–Ω–æ–≤–ª—é—î–º–æ –≤–º—ñ—Å—Ç –ø—ñ–¥–∫–∞–∑–∫–∏ –¥–ª—è –º–∞–π–±—É—Ç–Ω—ñ—Ö –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω—å
            ps.marker.unbindTooltip();
            ps.marker.bindTooltip(newContent, {
                permanent: false,
                direction: 'top'
            });
        }

        function blinkPowerStation(stationName) {
            const ps = powerStationMarkers[stationName];
            if (!ps) return;

            // –û–Ω–æ–≤–ª—é—î–º–æ –ø—ñ–¥–∫–∞–∑–∫—É
            updatePowerStationTooltip(stationName);

            let blinkCount = 0;
            const maxBlinks = 6;
            const blinkInterval = 200;

            const blinkIntervalId = setInterval(() => {
                if (blinkCount >= maxBlinks) {
                    clearInterval(blinkIntervalId);
                    ps.marker.setStyle({
                        color: '#43a047',
                        fillColor: '#43a047'
                    });
                    return;
                }

                if (blinkCount % 2 === 0) {
                    ps.marker.setStyle({
                        color: '#ffeb3b',
                        fillColor: '#ffeb3b'
                    });
                } else {
                    ps.marker.setStyle({
                        color: '#43a047',
                        fillColor: '#43a047'
                    });
                }

                blinkCount++;
            }, blinkInterval);
        }

        function buyAutoRepair() {
            if (!lineUpgrades.autoRepair.unlocked) {
                if (energyResources >= lineUpgrades.autoRepair.cost) {
                    energyResources -= lineUpgrades.autoRepair.cost;
                    lineUpgrades.autoRepair.unlocked = true;
                    lineUpgrades.autoRepair.active = true;
                    updateResourceUI();
                    updateUpgradeButtons();
                    startAutoRepair();
                    showWarning("–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π —Ä–µ–º–æ–Ω—Ç –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ —Ç–∞ —É–≤—ñ–º–∫–Ω–µ–Ω–æ!", true);
                } else {
                    showWarning(`–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ä–µ—Å—É—Ä—Å—ñ–≤! –ü–æ—Ç—Ä—ñ–±–Ω–æ ${lineUpgrades.autoRepair.cost} –ú–í—Ç¬∑–≥–æ–¥`, false);
                }
            }
            else {
                lineUpgrades.autoRepair.active = !lineUpgrades.autoRepair.active;
                updateUpgradeButtons();
                if (lineUpgrades.autoRepair.active) {
                    startAutoRepair();
                    showWarning("–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π —Ä–µ–º–æ–Ω—Ç —É–≤—ñ–º–∫–Ω–µ–Ω–æ!", true);
                } else {
                    clearAllAutoRepairs();
                    showWarning("–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π —Ä–µ–º–æ–Ω—Ç –≤–∏–º–∫–Ω–µ–Ω–æ!", false);
                }
            }
        }

        function startAutoRepair() {
            if (!lineUpgrades.autoRepair.unlocked || !lineUpgrades.autoRepair.active) return;

            const damagedLines = lineLayers.filter(line => line.damaged);

            if (repairTeams > 0 && damagedLines.length > 0) {
                const lineToRepair = damagedLines[0];
                repairTeams--;
                updateTeamStatus();

                const repairTime = repairTimes['line'] * lineUpgrades.autoRepair.repairSpeed *
                    lineUpgrades.repairTimes[lineUpgrades.level];

                showProgressBar(lineToRepair.damageMarker.getLatLng(), repairTime, () => {
                    repairLine(lineToRepair);
                    repairTeams++;
                    updateTeamStatus();
                    setTimeout(startAutoRepair, 0);
                });
            }
        }

        function clearAllAutoRepairs() {
            lineLayers.forEach(line => {
                if (line.repairTimer) {
                    clearTimeout(line.repairTimer);
                    line.repairTimer = null;
                }
            });
        }

        function updateUpgradeButtons() {
            const lineBtn = document.getElementById('lineUpgradeBtn');
            const autoRepairBtn = document.getElementById('autoRepairBtn');

            if (lineBtn) {
                const lvl = lineUpgrades.level;
                const next = lvl + 1;

                if (next <= lineUpgrades.maxLevel) {
                    if (next <= lineUpgrades.maxLevel) {
                        const cost = lineUpgrades.costs[next];
                        const name = lineUpgrades.levels[next];
                        const dmg = lineUpgrades.damageChances[next];
                        const repair = lineUpgrades.repairTimes[next];
                        lineBtn.innerHTML = `–ü–æ–∫—Ä–∞—â–∏—Ç–∏ –ª—ñ–Ω—ñ—ó (${cost} –ú–í—Ç¬∑–≥–æ–¥)<br>
                    ‚Üí <b>${name}</b><br>
                    –®–∞–Ω—Å –ø–æ—à–∫–æ–¥–∂–µ–Ω–Ω—è: <b>${Math.round(dmg * 100)}%</b><br>
                    –ß–∞—Å —Ä–µ–º–æ–Ω—Ç—É: <b>${Math.round((1 - repair) * 100)}% —à–≤–∏–¥—à–µ</b>`;
                        lineBtn.disabled = false;
                    }
                } else {
                    lineBtn.innerHTML = `–õ—ñ–Ω—ñ—ó: ${lineUpgrades.levels[lvl]} (–º–∞–∫—Å)`;
                    lineBtn.disabled = true;
                }
            }

            if (autoRepairBtn) {
                if (!lineUpgrades.autoRepair.unlocked) {
                    autoRepairBtn.innerHTML = `–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π —Ä–µ–º–æ–Ω—Ç (${lineUpgrades.autoRepair.cost} –ú–í—Ç¬∑–≥–æ–¥)`;
                    autoRepairBtn.disabled = false;
                } else {
                    autoRepairBtn.innerHTML = lineUpgrades.autoRepair.active
                        ? "üî¥ –í–∏–º–∫–Ω—É—Ç–∏ –∞–≤—Ç–æ—Ä–µ–º–æ–Ω—Ç"
                        : "üü¢ –£–≤—ñ–º–∫–Ω—É—Ç–∏ –∞–≤—Ç–æ—Ä–µ–º–æ–Ω—Ç";
                    autoRepairBtn.disabled = false;
                }
            }
        }

        function buildGraph() {
            const graph = {};
            Object.keys(cities).forEach(name => graph[name] = []);
            Object.keys(powerStationMarkers).forEach(name => graph[name] = []);

            for (const { from, to, damaged } of lineLayers) {
                if (!damaged) {
                    graph[from].push(to);
                    graph[to].push(from);
                }
            }
            return graph;
        }

        function showWarning(message, isGoodNews = false) {
            const warning = document.createElement('div');
            warning.className = `warning-message ${isGoodNews ? 'good-news' : 'bad-news'}`;
            warning.textContent = message;
            document.body.appendChild(warning);
            setTimeout(() => warning.remove(), 4000);
        }

        function updateCityHealthIndicator(cityName, show) {
            if (show) {
                if (!cityHealthMarkers[cityName]) {
                    const container = L.DomUtil.create('div', 'health-container');
                    L.DomUtil.create('div', 'health-bar', container);

                    const icon = L.divIcon({
                        className: '',
                        html: container.outerHTML,
                        iconSize: [60, 6],
                        iconAnchor: [30, 0]
                    });

                    const marker = L.marker(cities[cityName].coords, {
                        icon,
                        zIndexOffset: 1000
                    }).addTo(map);

                    cityHealthMarkers[cityName] = {
                        marker
                    };

                    setTimeout(() => updateHealthBar(cityName, cityHealth[cityName].current), 0);
                } else {
                    cityHealthMarkers[cityName].marker.setOpacity(1);
                }
            } else if (cityHealthMarkers[cityName]) {
                cityHealthMarkers[cityName].marker.setOpacity(0);
            }
        }

        function updateHealthBar(cityName, percentage) {
            const healthMarker = cityHealthMarkers[cityName];
            if (healthMarker) {
                const el = healthMarker.marker.getElement();
                if (el) {
                    const bar = el.querySelector('.health-bar');
                    if (bar) {
                        bar.style.width = `${percentage}%`;
                    }
                }
            }
        }

        function startHealthDecrease(cityName) {
            if (cityHealth[cityName].timer) return;

            cityHealth[cityName].current = 100;
            updateHealthBar(cityName, 100);

            const decreaseInterval = 100;
            const totalTime = 60000;
            const steps = totalTime / decreaseInterval;
            const decreasePerStep = 100 / steps;

            cityHealth[cityName].timer = setInterval(() => {
                cityHealth[cityName].current = Math.max(0, cityHealth[cityName].current - decreasePerStep);
                updateHealthBar(cityName, cityHealth[cityName].current);

                if (cityHealth[cityName].current <= 0) {
                    clearInterval(cityHealth[cityName].timer);
                    cityHealth[cityName].timer = null;
                    disableCity(cityName);
                    showWarning(`${cityName} –≤—Ç—Ä–∞—Ç–∏–≤ –≤—Å—ñ —Ä–µ—Å—É—Ä—Å–∏!`, false);
                }
            }, decreaseInterval);
        }

        function disableCity(cityName) {
            const marker = cityMarkers[cityName];

            const disabledLayer = L.divIcon({
                className: 'city-disabled',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });

            const disabledMarker = L.marker(cities[cityName].coords, {
                icon: disabledLayer,
                interactive: false,
                zIndexOffset: -1
            }).addTo(map);

            cityDisabledLayers[cityName] = disabledMarker;

            if (cityHealthMarkers[cityName]) {
                cityHealthMarkers[cityName].marker.setOpacity(0);
            }

            marker.setStyle({
                fillOpacity: 0,
                opacity: 0
            });
            loseLife();
        }

        function enableCity(cityName) {
            const marker = cityMarkers[cityName];

            if (cityDisabledLayers[cityName]) {
                map.removeLayer(cityDisabledLayers[cityName]);
                delete cityDisabledLayers[cityName];
            }

            marker.setStyle({
                fillOpacity: 1,
                opacity: 1
            });
        }

        function stopHealthDecrease(cityName) {
            if (cityHealth[cityName].timer) {
                clearInterval(cityHealth[cityName].timer);
                cityHealth[cityName].timer = null;
            }
        }

        function resetCityHealth(cityName) {
            cityHealth[cityName].current = 100;
            updateHealthBar(cityName, 100);
            enableCity(cityName);
        }

        function createTooltipContent(name, powerInfo) {
            return `<b>${name}</b><div class="power-info">${powerInfo}</div>`;
        }

        for (const [name, data] of Object.entries(cities)) {
            const marker = L.circleMarker(data.coords, {
                radius: 6,
                color: '#4fc3f7',
                fillColor: '#4fc3f7',
                fillOpacity: 1,
                opacity: 1,
                zIndexOffset: 1000
            }).addTo(map);

            marker.bindTooltip(createTooltipContent(name, `–ü–æ—Ç—Ä–µ–±–∞: ${data.powerNeed} –ú–í—Ç`), {
                permanent: false,
                direction: 'top'
            });

            cityMarkers[name] = marker;
            cityHealth[name] = { current: 100, timer: null, powered: true };
        }

        function showProgressBar(latlng, duration, onComplete) {
            const container = L.DomUtil.create('div', 'progress-container');
            L.DomUtil.create('div', 'progress-bar', container);

            const icon = L.divIcon({
                className: '',
                html: container.outerHTML,
                iconSize: [60, 8],
                iconAnchor: [30, 0]
            });

            const marker = L.marker(latlng, { icon }).addTo(map);

            let start = null;
            function animate(timestamp) {
                if (!start) start = timestamp;
                const progress = (timestamp - start) / duration;

                const el = marker.getElement();
                if (el) {
                    const barEl = el.querySelector('.progress-bar');
                    if (barEl) {
                        barEl.style.width = `${Math.min(progress * 100, 100)}%`;
                    }
                }

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    map.removeLayer(marker);
                    onComplete();
                }
            }

            requestAnimationFrame(animate);
        }

        powerStations.forEach((station) => {
            const marker = L.circleMarker(station.coords, {
                radius: 10,
                color: '#43a047',
                fillColor: '#43a047',
                fillOpacity: 1,
                zIndexOffset: 2000
            }).addTo(map);

            marker.bindTooltip(createTooltipContent(
                `${station.name} (${station.type})`,
                `–ü–æ—Ç—É–∂–Ω—ñ—Å—Ç—å: ${station.powerOutput} –ú–í—Ç`
            ), { permanent: false, direction: 'top' });

            powerStationMarkers[station.name] = {
                marker,
                fire: null,
                damaged: false,
                type: station.type,
                powerOutput: station.powerOutput
            };

            marker.on('click', () => {
                repairPowerStation(station.name);
                // –û–Ω–æ–≤–ª—é—î–º–æ –ø—ñ–¥–∫–∞–∑–∫—É –ø—ñ—Å–ª—è —Ä–µ–º–æ–Ω—Ç—É
                updatePowerStationTooltip(station.name);
            });
        });

        function repairPowerStation(name) {
            const ps = powerStationMarkers[name];
            if (!ps.damaged) return;

            if (repairTeams <= 0) {
                showWarning("–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –±—Ä–∏–≥–∞–¥! –ó–∞—á–µ–∫–∞–π—Ç–µ, –ø–æ–∫–∏ –∑–≤—ñ–ª—å–Ω–∏—Ç—å—Å—è —Ö–æ—á–∞ –± –æ–¥–Ω–∞.", false);
                return;
            }

            repairTeams--;
            updateTeamStatus();

            showProgressBar(ps.marker.getLatLng(), repairTimes[ps.type] * difficultyMultiplier, () => {
                ps.damaged = false;
                if (ps.fire) {
                    map.removeLayer(ps.fire);
                    ps.fire = null;
                }
                ps.marker.setStyle({
                    color: '#43a047',
                    fillColor: '#43a047'
                });
                repairTeams++;
                updateTeamStatus();
                updateCityPowerStatus();
                updateIncomeRate(); // –û–Ω–æ–≤–ª—é—î–º–æ –¥–æ—Ö—ñ–¥ –ø—ñ—Å–ª—è —Ä–µ–º–æ–Ω—Ç—É
            });
        }

        function repairLine(line) {
            if (!line.damaged) return;

            line.damaged = false;
            line.line.setStyle({
                color: lineUpgrades.colors[lineUpgrades.level],
                weight: lineUpgrades.weights[lineUpgrades.level]
            });
            line.damageMarker.setOpacity(0);

            if (line.repairTimer) {
                clearTimeout(line.repairTimer);
                line.repairTimer = null;
            }

            updateCityPowerStatus();
            updateIncomeRate(); // –û–Ω–æ–≤–ª—é—î–º–æ –¥–æ—Ö—ñ–¥ –ø—ñ—Å–ª—è —Ä–µ–º–æ–Ω—Ç—É
        }

        function midpoint(coord1, coord2) {
            return [(coord1[0] + coord2[0]) / 2, (coord1[1] + coord2[1]) / 2];
        }

        function hasPath(graph, start, goal) {
            if (start === goal) return true;
            const visited = new Set();
            const queue = [start];
            while (queue.length) {
                const node = queue.shift();
                if (node === goal) return true;
                visited.add(node);
                for (const neighbor of graph[node] || []) {
                    if (!visited.has(neighbor)) queue.push(neighbor);
                }
            }
            return false;
        }

        function updateTeamStatus() {
            const teamElement = document.createElement('div');
            teamElement.id = 'teamsStatus';
            teamElement.innerHTML = `–†–µ–º–æ–Ω—Ç–Ω—ñ –±—Ä–∏–≥–∞–¥–∏: <span style="color:${repairTeams > 0 ? 'green' : 'red'}">${repairTeams}</span>`;

            const statusPanel = document.getElementById('statusPanel');
            const existingTeamElement = document.getElementById('teamsStatus');

            if (existingTeamElement) {
                statusPanel.replaceChild(teamElement, existingTeamElement);
            } else {
                statusPanel.appendChild(teamElement);
            }
        }

        function calculatePowerDistribution() {
            const graph = buildGraph();

            const workingStations = Object.entries(powerStationMarkers)
                .filter(([_, ps]) => !ps.damaged)
                .map(([name, ps]) => ({
                    name,
                    powerOutput: ps.powerOutput,
                    remainingPower: ps.powerOutput,
                    cities: []
                }));

            workingStations.sort((a, b) => b.powerOutput - a.powerOutput);

            const result = {};
            const poweredCities = new Set();

            for (const station of workingStations) {
                const reachableCities = Object.keys(cities).filter(city =>
                    !poweredCities.has(city) && hasPath(graph, city, station.name)
                );

                reachableCities.sort((a, b) => {
                    const distA = getDistance(cities[a].coords, powerStationMarkers[station.name].marker.getLatLng());
                    const distB = getDistance(cities[b].coords, powerStationMarkers[station.name].marker.getLatLng());
                    return distA - distB;
                });

                for (const city of reachableCities) {
                    if (station.remainingPower >= cities[city].powerNeed) {
                        station.cities.push(city);
                        station.remainingPower -= cities[city].powerNeed;
                        poweredCities.add(city);
                        result[city] = true;
                    }
                }
            }

            const totalProduction = workingStations.reduce((sum, s) => sum + s.powerOutput, 0);
            const totalConsumption = Object.values(cities).reduce((sum, c) => sum + c.powerNeed, 0);
            const poweredConsumption = workingStations.reduce((sum, s) => sum + (s.powerOutput - s.remainingPower), 0);

            return {
                distribution: result,
                stats: { totalProduction, totalConsumption, poweredConsumption }
            };
        }

        function getDistance(latLng1, latLng2) {
            const R = 6371;
            const dLat = (latLng2[0] - latLng1[0]) * Math.PI / 180;
            const dLon = (latLng2[1] - latLng1[1]) * Math.PI / 180;
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(latLng1[0] * Math.PI / 180) * Math.cos(latLng2[0] * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        function updateStatusPanel(poweredCities, totalCities, stats) {
            const psStats = { '–ì–ï–°': [0, 0], '–ê–ï–°': [0, 0], '–¢–ï–°': [0, 0], '–í–ï–°': [0, 0] };
            for (const { name, type } of powerStations) {
                const ps = powerStationMarkers[name];
                if (ps.damaged) psStats[type][1]++;
                else psStats[type][0]++;
            }

            let workingLines = 0, damagedLines = 0;
            for (const conn of lineLayers) {
                if (conn.damaged) damagedLines++;
                else workingLines++;
            }

            const color = (good, total) => {
                const damaged = total - good;
                return `<span style="color:red;">${damaged}</span> / <span style="color:green;">${total}</span>`;
            };

            const statusHTML = `
        <div><strong>–ú—ñ—Å—Ç–∞ –∑—ñ —Å–≤—ñ—Ç–ª–æ–º:</strong> ${poweredCities} –∑ ${totalCities}</div>
        <div><strong>–ì–ï–°:</strong> ${color(psStats['–ì–ï–°'][0], psStats['–ì–ï–°'][0] + psStats['–ì–ï–°'][1])}</div>
        <div><strong>–ê–ï–°:</strong> ${color(psStats['–ê–ï–°'][0], psStats['–ê–ï–°'][0] + psStats['–ê–ï–°'][1])}</div>
        <div><strong>–¢–ï–°:</strong> ${color(psStats['–¢–ï–°'][0], psStats['–¢–ï–°'][0] + psStats['–¢–ï–°'][1])}</div>
        <div><strong>–í–ï–°:</strong> ${color(psStats['–í–ï–°'][0], psStats['–í–ï–°'][0] + psStats['–í–ï–°'][1])}</div>
        <div><strong>–õ—ñ–Ω—ñ—ó:</strong> ${color(workingLines, workingLines + damagedLines)}</div>
        <div><strong>–í–∏—Ä–æ–±–Ω–∏—Ü—Ç–≤–æ:</strong> ${Math.round(stats.totalProduction)} –ú–í—Ç</div>
        <div><strong>–°–ø–æ–∂–∏–≤–∞–Ω–Ω—è:</strong> ${Math.round(stats.totalConsumption)} –ú–í—Ç</div>
        <div><strong>–ü–æ—Ç–æ—á–Ω–∏–π –±–∞–ª–∞–Ω—Å:</strong> ${Math.round(stats.totalProduction - stats.totalConsumption)} –ú–í—Ç</div>
        <div><strong>–î–µ—Ñ—ñ—Ü–∏—Ç:</strong> ${Math.round(stats.poweredConsumption - stats.totalConsumption)} –ú–í—Ç</div>
        <div id="teamsStatus"></div>
    `;

            document.getElementById('statusPanel').innerHTML = statusHTML;
            updateTeamStatus();
        }

        function updateResourceUI() {
            document.getElementById("energyResources").textContent = Math.floor(energyResources);
        }

        function buyUpgrade(type) {
            const upgrade = upgrades[type];
            if (energyResources >= upgrade.cost) {
                energyResources -= upgrade.cost;
                updateResourceUI();

                const result = upgrade.effect();

                if (type === 'powerPlant' && result) {
                    const ps = powerStationMarkers[result];
                    showWarning(`${ps.type} "${result}" –ø–æ–∫—Ä–∞—â–µ–Ω–æ! +200 –ú–í—Ç`, true);
                    blinkPowerStation(result);
                } else {
                    showWarning(`–ê–ø–≥—Ä–µ–π–¥ "${type}" –∫—É–ø–ª–µ–Ω–æ! –í–∏—Ç—Ä–∞—á–µ–Ω–æ ${upgrade.cost} –ú–í—Ç¬∑–≥–æ–¥`, true);
                }

                updateCityPowerStatus();
                updateIncomeRate();
            } else {
                showWarning(`–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ä–µ—Å—É—Ä—Å—ñ–≤! –ü–æ—Ç—Ä—ñ–±–Ω–æ ${upgrade.cost} –ú–í—Ç¬∑–≥–æ–¥`, false);
            }
        }

        function updateCityPowerStatus() {
            const { distribution, stats } = calculatePowerDistribution();
            updateIncomeRate(); // –û–Ω–æ–≤–ª—é—î–º–æ –¥–æ—Ö—ñ–¥ –ø—Ä–∏ –∑–º—ñ–Ω—ñ —Å—Ç–∞—Ç—É—Å—É –º—ñ—Å—Ç

            for (const [city, marker] of Object.entries(cityMarkers)) {
                const powered = distribution[city] || false;
                const wasPowered = cityHealth[city].powered;
                cityHealth[city].powered = powered;

                if (wasPowered !== powered) {
                    if (powered) {
                        stopHealthDecrease(city);
                        resetCityHealth(city);
                        updateCityHealthIndicator(city, false);
                        marker.setStyle({
                            fillColor: '#4fc3f7',
                            color: '#4fc3f7'
                        });
                    } else {
                        resetCityHealth(city);
                        updateCityHealthIndicator(city, true);
                        startHealthDecrease(city);
                        marker.setStyle({
                            fillColor: 'black',
                            color: 'black'
                        });
                    }
                }
            }

            const poweredCount = Object.values(distribution).filter(v => v).length;
            updateStatusPanel(poweredCount, Object.keys(cityMarkers).length, stats);
            updateIncomeRate();
        }

        connections.forEach(([from, to]) => {
            const latlngs = [
                cities[from]?.coords || powerStations.find(p => p.name === from)?.coords,
                cities[to]?.coords || powerStations.find(p => p.name === to)?.coords
            ];

            const line = L.polyline(latlngs, {
                color: lineUpgrades.colors[lineUpgrades.level],
                weight: lineUpgrades.weights[lineUpgrades.level]
            }).addTo(map).bringToBack();

            const damageMarker = L.marker(midpoint(latlngs[0], latlngs[1]), {
                icon: L.divIcon({
                    className: 'damage-icon',
                    html: '<span style="font-size:24px;line-height:24px;">‚ö°</span>',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                }),
                zIndexOffset: 0
            }).addTo(map).setOpacity(0);

            const conn = {
                from,
                to,
                line,
                damaged: false,
                damageMarker,
                repairTimer: null
            };
            lineLayers.push(conn);

            damageMarker.on('click', () => {
                if (!conn.damaged || repairTeams <= 0) return;

                if (lineUpgrades.autoRepair.unlocked && conn.repairTimer) {
                    showWarning("–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π —Ä–µ–º–æ–Ω—Ç –≤–∂–µ –≤–∏–∫–æ–Ω—É—î —Ü—é —Ä–æ–±–æ—Ç—É!", false);
                    return;
                }

                repairTeams--;
                updateTeamStatus();

                if (conn.repairTimer) {
                    clearTimeout(conn.repairTimer);
                    conn.repairTimer = null;
                }

                const repairTime = repairTimes['line'] * difficultyMultiplier *
                    lineUpgrades.repairTimes[lineUpgrades.level];

                showProgressBar(damageMarker.getLatLng(), repairTime, () => {

                    repairLine(conn);
                    repairTeams++;
                    updateTeamStatus();

                    if (lineUpgrades.autoRepair.unlocked) {
                        startAutoRepair();
                    }
                });
            });
        });

        function simulateAttack() {
            if (!isGameRunning) return;

            let attackExecuted = false;
            const now = Date.now();

            if (Math.random() < 0.7) {
                const workingLines = lineLayers.filter(line => !line.damaged);
                if (workingLines.length > 0) {
                    const randomLine = workingLines[Math.floor(Math.random() * workingLines.length)];

                    const dmgChance = lineUpgrades.damageChances[lineUpgrades.level];
                    if (Math.random() < dmgChance) {
                        randomLine.damaged = true;
                        randomLine.line.setStyle({ color: '#ff0000' });
                        randomLine.damageMarker.setOpacity(1);
                        attackExecuted = true;

                        if (lineUpgrades.autoRepair.unlocked && lineUpgrades.autoRepair.active) {
                            if (repairTeams > 0 && !randomLine.repairInProgress) {
                                randomLine.repairInProgress = true;
                                repairTeams--;
                                updateTeamStatus();

                                const repairTime = repairTimes['line'] *
                                    lineUpgrades.autoRepair.repairSpeed *
                                    lineUpgrades.repairTimes[lineUpgrades.level];

                                showProgressBar(
                                    randomLine.damageMarker.getLatLng(),
                                    repairTime,
                                    () => {
                                        if (randomLine.damaged) {
                                            repairLine(randomLine);
                                        }
                                        randomLine.repairInProgress = false;
                                        repairTeams++;
                                        updateTeamStatus();
                                    }
                                );
                            } else if (repairTeams <= 0) {
                                randomLine.repairTimer = setTimeout(() => {
                                    if (randomLine.damaged && lineUpgrades.autoRepair.active) {
                                        repairLine(randomLine);
                                    }
                                }, 2000);
                            }
                        }
                    } else {
                        showWarning("–ê—Ç–∞–∫–∞ –≤—ñ–¥–±–∏—Ç–∞! –ú—ñ—Ü–Ω—ñ –ª—ñ–Ω—ñ—ó –≤–∏—Ç—Ä–∏–º–∞–ª–∏ —É–¥–∞—Ä.", true);
                    }
                }
            }

            if (!attackExecuted && Math.random() < 0.3) {
                const workingStations = Object.values(powerStationMarkers)
                    .filter(ps => !ps.damaged && ps.type === '–¢–ï–°');

                if (workingStations.length > 0) {
                    const randomStation = workingStations[Math.floor(Math.random() * workingStations.length)];
                    randomStation.damaged = true;
                    randomStation.fire = L.marker(randomStation.marker.getLatLng(), {
                        icon: L.divIcon({
                            className: 'fire-icon',
                            html: '<span style="font-size:20px;line-height:20px;">üî•</span>',
                            iconSize: [20, 20],
                            iconAnchor: [10, 20]
                        }),
                        zIndexOffset: 2001
                    }).addTo(map);
                    randomStation.marker.setStyle({
                        color: '#e57373',
                        fillColor: '#e57373'
                    });
                    attackExecuted = true;
                }
            }

            if (attackExecuted) {
                updateCityPowerStatus();

                if (lineUpgrades.autoRepair.unlocked && lineUpgrades.autoRepair.active) {
                    setTimeout(() => {
                        const damagedLines = lineLayers.filter(line =>
                            line.damaged &&
                            !line.repairInProgress &&
                            !line.repairTimer
                        );

                        if (damagedLines.length > 0 && repairTeams > 0) {
                            const lineToRepair = damagedLines[0];
                            lineToRepair.repairInProgress = true;
                            repairTeams--;
                            updateTeamStatus();

                            const repairTime = repairTimes['line'] *
                                lineUpgrades.autoRepair.repairSpeed *
                                lineUpgrades.repairTimes[lineUpgrades.level];

                            showProgressBar(
                                lineToRepair.damageMarker.getLatLng(),
                                repairTime,
                                () => {
                                    repairLine(lineToRepair);
                                    repairTeams++;
                                    updateTeamStatus();
                                }
                            );
                        }
                    }, 1500);
                }
            }

            difficultyMultiplier = Math.min(2, 0.7 + (now - gameStartTime) / 1800000);
            scheduleNextAttack();
        }

        function scheduleNextAttack() {
            const now = Date.now();
            const timeSinceLast = now - lastAttackTime;
            const timeSinceStart = (now - gameStartTime) / 60000;

            if (timeSinceStart < 0.083) {
                setTimeout(() => {
                    simulateAttack();
                    lastAttackTime = Date.now();
                }, 2000);
                return;
            }

            const baseDelay = Math.max(5000, 15000 - timeSinceStart * 300);
            const dynamicDelay = Math.min(20000, Math.max(3000, baseDelay));

            setTimeout(() => {
                simulateAttack();
                lastAttackTime = Date.now();
                difficultyMultiplier = Math.min(2, 0.7 + timeSinceStart / 30);
            }, dynamicDelay);
        }

        // –§—É–Ω–∫—Ü—ñ—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è –∂–∏—Ç—Ç—ñ–≤
        function updateLivesDisplay() {
            const lifeElements = document.querySelectorAll('.life');
            lifeElements.forEach((el, index) => {
                el.style.display = index < lives ? 'inline-block' : 'none';
            });
        }

        // –§—É–Ω–∫—Ü—ñ—è –≤—Ç—Ä–∞—Ç–∏ –∂–∏—Ç—Ç—è
        function loseLife() {
            if (isGameOver) return;

            lives--;
            updateLivesDisplay();

            if (lives <= 0) {
                endGame();
            } else {
                showWarning("–í–∏ –≤—Ç—Ä–∞—Ç–∏–ª–∏ –æ–¥–Ω–µ –∂–∏—Ç—Ç—è!", false);
            }
        }

        // –§—É–Ω–∫—Ü—ñ—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –≥—Ä–∏
        function endGame() {
            isGameOver = true;
            document.getElementById('game-over').style.display = 'flex';
            clearInterval(balanceUpdateInterval);
            clearTimeout(attackTimeout);
        }

        // –§—É–Ω–∫—Ü—ñ—è —Ä–µ—Å—Ç–∞—Ä—Ç—É –≥—Ä–∏
        function restartGame() {
            document.getElementById('game-over').style.opacity = '0';
            setTimeout(() => location.reload(), 500);
        }

        document.getElementById('restart-button').addEventListener('click', restartGame);

        document.getElementById('toggleUpgradesPanel').addEventListener('click', function () {
            const panel = document.getElementById('upgradesPanel');
            panel.classList.toggle('collapsed');
            this.textContent = panel.classList.contains('collapsed') ? '‚öôÔ∏è' : '‚úï';
            this.style.right = panel.classList.contains('collapsed') ? '10px' : '320px';
        });

        document.getElementById('toggleStatusPanel').addEventListener('click', function () {
            const panel = document.getElementById('statusPanel');
            panel.classList.toggle('collapsed');
            this.textContent = panel.classList.contains('collapsed') ? '‚ÑπÔ∏è' : '‚úï';
            this.style.left = panel.classList.contains('collapsed') ? '10px' : '320px';
        });

        // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ
        document.addEventListener('DOMContentLoaded', function () {
            const upgradesPanel = document.getElementById('upgradesPanel');
            const statusPanel = document.getElementById('statusPanel');
            const toggleUpgrades = document.getElementById('toggleUpgradesPanel');
            const toggleStatus = document.getElementById('toggleStatusPanel');

            // –ü–æ—á–∞—Ç–∫–æ–≤–∏–π —Å—Ç–∞–Ω - —Å—Ö–æ–≤–∞–Ω–æ
            upgradesPanel.classList.add('collapsed');
            statusPanel.classList.add('collapsed');

            // –ü–æ–∑–∏—Ü—ñ–æ–Ω—É—î–º–æ –∫–Ω–æ–ø–∫–∏
            toggleUpgrades.style.right = '10px';
            toggleStatus.style.left = '10px';

            // –Ü–Ω—à—ñ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó...
            updateTeamStatus();
            updateCityPowerStatus();
            updateUpgradeButtons();
            updateIncomeRate();
            balanceUpdateInterval = setInterval(updateBalancePeriodically, 1000);
            scheduleNextAttack();
            updateLivesDisplay();
        });
    </script>
</body>

</html>
