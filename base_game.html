<!DOCTYPE html>
<html lang="uk">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lights Over Ukraine</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="icon" href="src/icon.png" type="image/png">
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
        }

        #map {
            height: 100vh;
            width: 100vw;
        }

        /* Покращені стилі для міст */
        .city-marker {
            border-radius: 50%;
            border: 3px solid #fff;
            box-shadow: 0 0 15px rgba(79, 195, 247, 0.8);
            animation: cityPulse 3s ease-in-out infinite;
        }

        .city-marker.powered {
            background: radial-gradient(circle, #4fc3f7 0%, #29b6f6 100%);
            box-shadow: 0 0 20px rgba(79, 195, 247, 1), 0 0 40px rgba(79, 195, 247, 0.5);
        }

        .city-marker.unpowered {
            background: radial-gradient(circle, #424242 0%, #212121 100%);
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.8);
            animation: cityDanger 1.5s ease-in-out infinite;
        }

        .city-marker.disabled {
            background: radial-gradient(circle, #757575 0%, #424242 100%);
            box-shadow: none;
            opacity: 0.5;
        }

        /* Покращені стилі для електростанцій */
        .power-station {
            border-radius: 50%;
            border: 4px solid #fff;
            position: relative;
            overflow: visible;
        }

        .power-station.working {
            background: radial-gradient(circle, #43a047 0%, #2e7d32 100%);
            box-shadow: 0 0 25px rgba(67, 160, 71, 1), 0 0 50px rgba(67, 160, 71, 0.3);
            animation: stationWorking 2s ease-in-out infinite;
        }

        .power-station.nuclear {
            background: radial-gradient(circle, #7e57c2 0%, #5e35b1 100%);
            box-shadow: 0 0 30px rgba(126, 87, 194, 1);
        }

        .power-station.thermal {
            background: radial-gradient(circle, #ff7043 0%, #d84315 100%);
            box-shadow: 0 0 25px rgba(255, 112, 67, 1);
        }

        .power-station.hydro {
            background: radial-gradient(circle, #29b6f6 0%, #1976d2 100%);
            box-shadow: 0 0 25px rgba(41, 182, 246, 1);
        }

        .power-station.wind {
            background: radial-gradient(circle, #66bb6a 0%, #388e3c 100%);
            box-shadow: 0 0 25px rgba(102, 187, 106, 1);
        }

        .power-station.damaged {
            background: radial-gradient(circle, #e57373 0%, #c62828 100%);
            box-shadow: 0 0 20px rgba(229, 115, 115, 1);
            animation: stationDamaged 0.8s ease-in-out infinite;
        }

        /* Анімації */
        @keyframes cityPulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.1);
                opacity: 0.8;
            }
        }

        @keyframes cityDanger {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.15);
            }
        }

        @keyframes stationWorking {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        @keyframes stationDamaged {

            0%,
            100% {
                transform: scale(1) rotate(0deg);
            }

            25% {
                transform: scale(1.1) rotate(-2deg);
            }

            75% {
                transform: scale(1.1) rotate(2deg);
            }
        }

        @keyframes lightningStrike {
            0% {
                opacity: 0;
                transform: scale(0.5);
            }

            20% {
                opacity: 1;
                transform: scale(1.2);
            }

            40% {
                opacity: 0.8;
                transform: scale(1);
            }

            100% {
                opacity: 0;
                transform: scale(0.8);
            }
        }

        @keyframes repairEffect {
            0% {
                opacity: 0;
                transform: scale(0.5) rotate(0deg);
            }

            50% {
                opacity: 1;
                transform: scale(1.2) rotate(180deg);
            }

            100% {
                opacity: 0;
                transform: scale(0.8) rotate(360deg);
            }
        }

        @keyframes upgradeEffect {
            0% {
                opacity: 0;
                transform: scale(0.3);
            }

            30% {
                opacity: 1;
                transform: scale(1.3);
            }

            60% {
                opacity: 0.8;
                transform: scale(1.1);
            }

            100% {
                opacity: 0;
                transform: scale(1.5);
            }
        }

        /* Ефекти частинок */
        .particle-effect {
            position: absolute;
            pointer-events: none;
            z-index: 10000;
        }

        .spark {
            width: 4px;
            height: 4px;
            background: #ffeb3b;
            border-radius: 50%;
            position: absolute;
            animation: sparkFly 1s ease-out forwards;
        }

        @keyframes sparkFly {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            100% {
                opacity: 0;
                transform: scale(0.5) translate(var(--tx), var(--ty));
            }
        }

        /* Покращені лінії електропередач */
        .power-line {
            stroke-dasharray: 10, 5;
            stroke-linecap: round;
            filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.3));
        }

        .power-line.damaged {
            stroke-dasharray: 5, 5;
            animation: lineDamaged 1s linear infinite;
        }

        @keyframes lineDamaged {
            0% {
                stroke-dashoffset: 0;
            }

            100% {
                stroke-dashoffset: 10;
            }
        }

        /* Іконки для різних типів станцій */
        .station-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
            color: white;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        .progress-container {
            width: 60px;
            height: 6px;
            background-color: rgba(100, 100, 100, 0.4);
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            border-radius: 3px;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.8);
        }

        .health-container {
            width: 60px;
            height: 6px;
            background-color: rgba(100, 100, 100, 0.4);
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }

        .health-bar {
            transition: width 0.1s linear;
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #f44336, #ff9800);
            border-radius: 3px;
        }

        .status-working {
            color: green;
        }

        .status-damaged {
            color: red;
        }

        .tooltip-hidden .leaflet-tooltip {
            display: none;
        }

        #teamsStatus {
            font-weight: bold;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #ddd;
        }

        .warning-message {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-family: sans-serif;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            animation: highlight 0.5s ease 2;
            animation-delay: 1s;
            background: rgba(40, 40, 40, 0.95);
            border-left: 4px solid;
            padding: 12px 20px;
            font-size: 15px;
            backdrop-filter: blur(2px);
        }

        .warning-message.good-news {
            animation: highlight-green 0.5s ease 2;
            animation-delay: 1s;
            border-color: #4CAF50;
            color: #C8E6C9;
        }

        .warning-message.bad-news {
            animation: highlight 0.5s ease 2;
            animation-delay: 1s;
            border-color: #F44336;
            color: #FFCDD2;
        }

        @keyframes highlight-green {
            0% {
                transform: translateX(-50%) scale(1);
            }

            50% {
                transform: translateX(-50%) scale(1.1);
            }

            100% {
                transform: translateX(-50%) scale(1);
            }
        }

        @keyframes highlight {
            0% {
                transform: translateX(-50%) scale(1);
            }

            50% {
                transform: translateX(-50%) scale(1.1);
            }

            100% {
                transform: translateX(-50%) scale(1);
            }
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                top: 10px;
            }
        }

        .city-disabled {
            background: radial-gradient(circle, rgba(120, 120, 120, 1) 0%, rgba(120, 120, 120, 0.8) 50%, rgba(120, 120, 120, 0) 100%);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            position: absolute;
            top: -8px;
            left: -8px;
            z-index: -1;
        }

        .leaflet-tooltip {
            font-size: 14px;
            white-space: nowrap;
        }

        .power-info {
            font-size: 12px;
            color: #555;
            margin-top: 3px;
        }

        .resource-panel {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 15px;
            border-radius: 10px;
            border-left: 4px solid #4CAF50;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            color: white;
            font-family: 'Arial', sans-serif;
        }

        .resource-icon {
            font-size: 24px;
            color: #FFEB3B;
        }

        .resource-values {
            line-height: 1.3;
        }

        .resource-amount {
            font-weight: bold;
            font-size: 18px;
        }

        .income-rate {
            font-size: 14px;
            color: #81C784;
        }

        .upgrade-btn {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 12px;
            background: linear-gradient(to right, #2C3E50, #4CA1AF);
            color: white;
            border: none;
            border-radius: 8px;
            text-align: left;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .upgrade-btn:enabled {
            background: linear-gradient(to right, #1E3C72, #2A5298);
            color: #FFF;
            border-left: 4px solid #FFD700;
        }

        .upgrade-btn:enabled:hover {
            background: linear-gradient(to right, #2A5298, #1E3C72);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .upgrade-btn:disabled {
            opacity: 0.6;
            background: linear-gradient(to right, #3a3a3a, #4a4a4a) !important;
            cursor: not-allowed;
        }

        .upgrade-btn:disabled .upgrade-cost {
            background: rgba(255, 0, 0, 0.3) !important;
        }

        .upgrade-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .upgrade-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .upgrade-icon {
            font-size: 20px;
            margin-right: 8px;
        }

        .upgrade-title {
            font-weight: bold;
            flex-grow: 1;
        }

        .upgrade-cost {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 14px;
        }

        .upgrade-effect {
            font-size: 13px;
            color: #B2EBF2;
            padding-left: 28px;
        }

        #upgradesPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 14px;
            border-radius: 10px;
            font-family: sans-serif;
            font-size: 14px;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            line-height: 1.4;
            width: 300px;
        }

        #upgradesPanel button:not(.upgrade-btn) {
            display: block;
            width: 100%;
            margin: 8px 0;
            padding: 8px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: #f8f8f8;
            text-align: left;
            transition: background 0.2s;
        }

        #upgradesPanel button:not(.upgrade-btn):disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        #upgradesPanel button:not(.upgrade-btn):hover {
            background: #e8e8e8;
        }

        #incomeRate {
            color: #2E7D32;
            font-weight: bold;
        }

        .panel-toggle {
            position: absolute;
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 1002;
            font-size: 16px;
            line-height: 1;
            padding: 0;
            border: none;
        }

        .panel-toggle:hover {
            background: #f0f0f0;
        }

        #toggleUpgradesPanel {
            top: 10px;
            right: 10px;
        }

        #toggleStatusPanel {
            bottom: 10px;
            left: 10px;
        }

        .hidden {
            display: none !important;
        }

        #upgradesPanel,
        #statusPanel {
            transition: transform 0.3s ease-in-out;
        }

        #upgradesPanel.collapsed {
            transform: translateX(calc(100% + 10px));
        }

        #statusPanel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 320px;

            background: rgba(0, 0, 0, 0.8);
            border-left: 4px solid #2196F3;
            border-radius: 12px;
            padding: 16px 18px;

            font-family: 'Arial', sans-serif;
            font-size: 14px;
            color: #f1f1f1;
            line-height: 1.5;

            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(5px);
            z-index: 1000;
            transition: transform 0.3s ease-in-out;
        }

        #statusPanel strong {
            color: #FFD700;
            font-weight: bold;
        }

        #statusPanel div {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        #statusPanel div:last-child {
            border-bottom: none;
        }

        #statusPanel span[style*="color:green"] {
            color: #81C784 !important;
            font-weight: bold;
        }

        #statusPanel span[style*="color:red"] {
            color: #E57373 !important;
            font-weight: bold;
        }

        #statusPanel.collapsed {
            transform: translateX(calc(-100% - 10px));
        }

        #lives-container {
            position: absolute;
            top: 15px;
            left: 4vw;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .life {
            font-size: 24px;
            color: #ff5252;
        }

        #game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
            font-family: sans-serif;
        }

        #game-over h2 {
            font-size: 36px;
            margin-bottom: 20px;
        }

        #restart-button {
            padding: 12px 24px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        #restart-button:hover {
            background: #45a049;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <div id="toggleUpgradesPanel" class="panel-toggle">⚙️</div>
    <div id="toggleStatusPanel" class="panel-toggle">ℹ️</div>
    <div id="statusPanel"></div>

    <div id="upgradesPanel">
        <div class="resource-panel">
            <div class="resource-icon">⚡</div>
            <div class="resource-values">
                <div class="resource-amount"><span id="energyResources">0</span> МВт·год</div>
                <div class="income-rate">+<span id="incomeRate">0</span> МВт/хв</div>
            </div>
        </div>

        <button class="upgrade-btn" onclick="buyUpgrade('team')">
            <div class="upgrade-header">
                <span class="upgrade-icon">👷</span>
                <span class="upgrade-title">+1 Бригада</span>
                <span class="upgrade-cost">100 МВт·год</span>
            </div>
            <div class="upgrade-effect">+50 МВт витрат</div>
        </button>

        <button class="upgrade-btn" onclick="buyUpgrade('powerPlant')">
            <div class="upgrade-header">
                <span class="upgrade-icon">🏭</span>
                <span class="upgrade-title">Покращити станцію</span>
                <span class="upgrade-cost">300 МВт·год</span>
            </div>
            <div class="upgrade-effect">+200 МВт потужності</div>
        </button>

        <button class="upgrade-btn" onclick="buyLineUpgrade()" id="lineUpgradeBtn">
            <div class="upgrade-header">
                <span class="upgrade-icon">🔌</span>
                <span class="upgrade-title">Покращити лінії</span>
                <span class="upgrade-cost" id="lineUpgradeCost">200 МВт·год</span>
            </div>
            <div class="upgrade-effect" id="lineUpgradeEffect">Рівень 1/3</div>
        </button>

        <button class="upgrade-btn" onclick="buyAutoRepair()" id="autoRepairBtn">
            <div class="upgrade-header">
                <span class="upgrade-icon">🤖</span>
                <span class="upgrade-title">Автоматичний ремонт</span>
                <span class="upgrade-cost">800 МВт·год</span>
            </div>
            <div class="upgrade-effect">Швидкість ремонту +50%</div>
        </button>
    </div>

    <div id="lives-container">
        <span class="life">❤️</span>
        <span class="life">❤️</span>
        <span class="life">❤️</span>
    </div>

    <div id="game-over">
        <h2>Гру завершено!</h2>
        <p>Ви витратили всі життя</p>
        <button id="restart-button">Грати знову</button>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        const map = L.map('map').setView([48.5, 31], 6);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        const cities = {
            'Київ': { coords: [50.45, 30.52], powerNeed: 1500 },
            'Львів': { coords: [49.84, 24.03], powerNeed: 800 },
            'Харків': { coords: [49.99, 36.23], powerNeed: 1200 },
            'Одеса': { coords: [46.48, 30.73], powerNeed: 900 },
            'Дніпро': { coords: [48.45, 34.98], powerNeed: 1100 },
            'Запоріжжя': { coords: [47.84, 35.14], powerNeed: 700 },
            'Луцьк': { coords: [50.75, 25.33], powerNeed: 400 },
            'Івано-Франківськ': { coords: [48.92, 24.71], powerNeed: 450 },
            'Тернопіль': { coords: [49.55, 25.59], powerNeed: 350 },
            'Рівне': { coords: [50.62, 26.25], powerNeed: 300 },
            'Чернівці': { coords: [48.29, 25.94], powerNeed: 400 },
            'Вінниця': { coords: [49.23, 28.48], powerNeed: 500 },
            'Житомир': { coords: [50.25, 28.66], powerNeed: 400 },
            'Полтава': { coords: [49.59, 34.55], powerNeed: 600 },
            'Кропивницький': { coords: [48.51, 32.26], powerNeed: 450 },
            'Миколаїв': { coords: [46.97, 31.99], powerNeed: 550 },
            'Херсон': { coords: [46.63, 32.6], powerNeed: 500 },
            'Чернігів': { coords: [51.5, 31.3], powerNeed: 450 },
            'Суми': { coords: [50.92, 34.78], powerNeed: 400 },
            'Ужгород': { coords: [48.62, 22.3], powerNeed: 350 },
            'Черкаси': { coords: [49.44, 32.06], powerNeed: 400 },
            'Хмельницький': { coords: [49.42, 27.0], powerNeed: 450 },
            'Краматорськ': { coords: [48.74, 37.58], powerNeed: 300 },
            'Маріуполь': { coords: [47.1, 37.55], powerNeed: 600 },
            'Сімферополь': { coords: [44.95, 34.1], powerNeed: 700 },
            'Севастополь': { coords: [44.61, 33.53], powerNeed: 500 },
            'Мелітополь': { coords: [46.85, 35.37], powerNeed: 250 },
            'Луганськ': { coords: [48.57, 39.32], powerNeed: 400 },
            'Керч': { coords: [45.35, 36.47], powerNeed: 200 },
            'Нікополь': { coords: [47.57, 34.4], powerNeed: 300 },
            'Біла Церква': { coords: [49.8, 30.12], powerNeed: 200 },
            'Кременчук': { coords: [49.07, 33.42], powerNeed: 350 },
            'Кривий Ріг': { coords: [47.91, 33.39], powerNeed: 800 }
        };

        const powerStations = [
            { name: 'Бурштинська ТЕС', coords: [49.26, 24.63], type: 'ТЕС', powerOutput: 2800 },
            { name: 'Південноукраїнська АЕС', coords: [47.82, 31.18], type: 'АЕС', powerOutput: 3500 },
            { name: 'Хмельницька АЕС', coords: [50.37, 26.64], type: 'АЕС', powerOutput: 2500 },
            { name: 'Київська ГЕС', coords: [50.58, 30.5], type: 'ГЕС', powerOutput: 500 },
            { name: 'Запорізька АЕС', coords: [47.51, 34.58], type: 'АЕС', powerOutput: 6500 },
            { name: 'Трипільська ТЕС', coords: [50.13, 30.79], type: 'ТЕС', powerOutput: 2200 },
            { name: 'Криворізька ТЕС', coords: [47.98, 33.38], type: 'ТЕС', powerOutput: 1600 },
            { name: 'Кременчуцька ГЕС', coords: [49.10, 33.42], type: 'ГЕС', powerOutput: 450 },
            { name: 'Ботієвська ВЕС', coords: [46.85, 36.0], type: 'ВЕС', powerOutput: 400 }
        ];

        const connections = [
            ['Київ', 'Житомир'], ['Ботієвська ВЕС', 'Запоріжжя'], ['Житомир', 'Рівне'], ['Рівне', 'Луцьк'], ['Луцьк', 'Львів'],
            ['Київ', 'Чернігів'], ['Київ', 'Черкаси'], ['Київ', 'Полтава'], ['Київ', 'Трипільська ТЕС'],
            ['Полтава', 'Харків'], ['Полтава', 'Краматорськ'], ['Краматорськ', 'Маріуполь'],
            ['Краматорськ', 'Дніпро'], ['Дніпро', 'Запоріжжя'], ['Дніпро', 'Криворізька ТЕС'],
            ['Дніпро', 'Кропивницький'], ['Кропивницький', 'Черкаси'], ['Кропивницький', 'Миколаїв'],
            ['Миколаїв', 'Одеса'], ['Миколаїв', 'Херсон'], ['Херсон', 'Сімферополь'],
            ['Сімферополь', 'Севастополь'], ['Вінниця', 'Київ'], ['Вінниця', 'Хмельницький'],
            ['Хмельницький', 'Тернопіль'], ['Тернопіль', 'Івано-Франківськ'],
            ['Івано-Франківськ', 'Чернівці'], ['Ужгород', 'Івано-Франківськ'],
            ['Суми', 'Харків'], ['Суми', 'Чернігів'],
            ['Південноукраїнська АЕС', 'Миколаїв'],
            ['Київська ГЕС', 'Київ'], ['Кременчуцька ГЕС', 'Кременчук'], ['Криворізька ТЕС', 'Кривий Ріг'],
            ['Трипільська ТЕС', 'Біла Церква'], ['Запорізька АЕС', 'Запоріжжя'],
            ['Мелітополь', 'Запоріжжя'], ['Луганськ', 'Краматорськ'],
            ['Керч', 'Сімферополь'], ['Нікополь', 'Запоріжжя'], ['Біла Церква', 'Київ'], ['Кременчук', 'Полтава'],
            ['Бурштинська ТЕС', 'Івано-Франківськ'],
            ['Хмельницька АЕС', 'Рівне'],
            ['Вінниця', 'Кропивницький']
        ];

        const cityMarkers = {};
        const lineLayers = [];
        const powerStationMarkers = {};
        const cityHealth = {};
        const cityHealthMarkers = {};
        const cityDisabledLayers = {};
        let repairTeams = 1;
        let difficultyMultiplier = 1;
        let lastAttackTime = Date.now();
        let gameStartTime = Date.now();
        let energyResources = 0;
        const efficiencyFactor = 0.05;
        let isGameRunning = true;
        let resourceUpdateCooldown = false;
        let currentIncomeRate = 0;
        let balanceUpdateInterval;
        let lives = 3;
        const maxLives = 3;
        let isGameOver = false;
        let attackTimeout;

        const repairTimes = {
            'АЕС': 8000,
            'ТЕС': 5000,
            'ГЕС': 4000,
            'ВЕС': 3000,
            'line': 2000
        };

        const upgrades = {
            team: {
                cost: 100,
                effect: () => {
                    repairTeams++;
                    const perCityIncrease = 50 / Object.keys(cities).length;
                    for (const city in cities) {
                        cities[city].powerNeed += perCityIncrease;
                    }
                }
            },
            powerPlant: {
                cost: 300,
                effect: () => {
                    const stationNames = Object.keys(powerStationMarkers)
                        .filter(name => powerStationMarkers[name].type !== 'АЕС');

                    if (stationNames.length === 0) {
                        showWarning("Немає доступних станцій для покращення!", false);
                        return null;
                    }
                    const name = stationNames[Math.floor(Math.random() * stationNames.length)];
                    powerStationMarkers[name].powerOutput += 200;
                    updatePowerStationTooltip(name);
                    return name;
                }
            }
        };

        const lineUpgrades = {
            level: 0,
            maxLevel: 3,
            levels: ["Базові", "Укріплені", "Надійні", "Ідеальні"],
            damageChances: [0.7, 0.55, 0.4, 0.25],
            repairTimes: [1.0, 0.85, 0.7, 0.55],
            costs: [0, 300, 500, 700],
            colors: ['#888', '#007BFF', '#4CAF50', '#FFD700'],
            weights: [2, 3, 4, 5],
            autoRepair: {
                unlocked: false,
                active: false,
                cost: 800,
                repairSpeed: 0.5
            }
        };

        // Функція для створення ефекту частинок
        function createParticleEffect(latLng, type = 'repair') {
            const mapContainer = document.getElementById('map');
            const point = map.latLngToContainerPoint(latLng);

            const colors = {
                repair: ['#4CAF50', '#8BC34A', '#CDDC39'],
                damage: ['#FF5722', '#FF9800', '#FFC107'],
                upgrade: ['#9C27B0', '#E91E63', '#2196F3']
            };

            const particleColors = colors[type] || colors.repair;

            for (let i = 0; i < 8; i++) {
                const particle = document.createElement('div');
                particle.className = 'spark';
                particle.style.background = particleColors[Math.floor(Math.random() * particleColors.length)];
                particle.style.left = point.x + 'px';
                particle.style.top = point.y + 'px';

                const angle = (Math.PI * 2 * i) / 8;
                const distance = 20 + Math.random() * 30;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;

                particle.style.setProperty('--tx', tx + 'px');
                particle.style.setProperty('--ty', ty + 'px');

                mapContainer.appendChild(particle);

                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, 1000);
            }
        }

        // Функція для створення ефекту блискавки
        function createLightningEffect(latLng) {
            const container = L.DomUtil.create('div', '');
            container.innerHTML = '<span style="font-size:32px;color:#ffeb3b;text-shadow:0 0 10px #ffeb3b;">⚡</span>';
            container.style.animation = 'lightningStrike 0.8s ease-out forwards';

            const icon = L.divIcon({
                className: '',
                html: container.outerHTML,
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });

            const marker = L.marker(latLng, { icon }).addTo(map);

            setTimeout(() => {
                map.removeLayer(marker);
            }, 800);
        }

        // Функція для створення ефекту ремонту
        function createRepairEffect(latLng) {
            const container = L.DomUtil.create('div', '');
            container.innerHTML = '<span style="font-size:28px;color:#4CAF50;text-shadow:0 0 8px #4CAF50;">🔧</span>';
            container.style.animation = 'repairEffect 1.5s ease-out forwards';

            const icon = L.divIcon({
                className: '',
                html: container.outerHTML,
                iconSize: [28, 28],
                iconAnchor: [14, 14]
            });

            const marker = L.marker(latLng, { icon }).addTo(map);

            setTimeout(() => {
                map.removeLayer(marker);
            }, 1500);
        }

        // Функція для створення ефекту апгрейду
        function createUpgradeEffect(latLng) {
            const container = L.DomUtil.create('div', '');
            container.innerHTML = '<span style="font-size:24px;color:#FFD700;text-shadow:0 0 12px #FFD700;">✨</span>';
            container.style.animation = 'upgradeEffect 2s ease-out forwards';

            const icon = L.divIcon({
                className: '',
                html: container.outerHTML,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });

            const marker = L.marker(latLng, { icon }).addTo(map);

            setTimeout(() => {
                map.removeLayer(marker);
            }, 2000);
        }

        // Виправлена функція для оновлення станції без втрати позиції
        function updatePowerStationVisual(stationName, damaged = false) {
            const ps = powerStationMarkers[stationName];
            if (!ps) return;

            const container = L.DomUtil.create('div', getStationClass(ps.type, damaged));
            container.style.width = '20px';
            container.style.height = '20px';

            const iconElement = L.DomUtil.create('div', 'station-icon', container);
            iconElement.innerHTML = getStationIcon(ps.type);

            const newIcon = L.divIcon({
                className: '',
                html: container.outerHTML,
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });

            ps.marker.setIcon(newIcon);
        }

        // Виправлена функція для оновлення міста без втрати позиції
        function updateCityVisual(cityName, className) {
            const marker = cityMarkers[cityName];
            if (!marker) return;

            const container = L.DomUtil.create('div', className);
            container.style.width = '12px';
            container.style.height = '12px';

            const newIcon = L.divIcon({
                className: '',
                html: container.outerHTML,
                iconSize: [12, 12],
                iconAnchor: [6, 6]
            });

            marker.setIcon(newIcon);
        }

        // Функція для отримання іконки типу станції
        function getStationIcon(type) {
            const icons = {
                'АЕС': '⚛️',
                'ТЕС': '🏭',
                'ГЕС': '💧',
                'ВЕС': '💨'
            };
            return icons[type] || '⚡';
        }

        // Функція для отримання CSS класу станції
        function getStationClass(type, damaged = false) {
            if (damaged) return 'power-station damaged';

            const classes = {
                'АЕС': 'power-station nuclear working',
                'ТЕС': 'power-station thermal working',
                'ГЕС': 'power-station hydro working',
                'ВЕС': 'power-station wind working'
            };
            return classes[type] || 'power-station working';
        }

        function updateIncomeRate() {
            const { stats } = calculatePowerDistribution();
            const currentSurplus = stats.totalProduction - stats.totalConsumption;

            if (currentSurplus > 0) {
                currentIncomeRate = Math.floor(currentSurplus * 0.01 * 60);
            } else {
                currentIncomeRate = 0;
            }

            document.getElementById("incomeRate").textContent = currentIncomeRate;
        }

        function updateBalancePeriodically() {
            if (currentIncomeRate > 0) {
                energyResources += currentIncomeRate / 60;
                updateResourceUI();
                updateUpgradeButtons();
            }
        }

        function buyLineUpgrade() {
            if (lineUpgrades.level >= lineUpgrades.maxLevel) {
                showWarning("Лінії вже максимально покращені!", false);
                return;
            }

            const next = lineUpgrades.level + 1;
            const cost = lineUpgrades.costs[next];

            if (energyResources >= cost) {
                energyResources -= cost;
                lineUpgrades.level = next;
                updateResourceUI();

                lineLayers.forEach(conn => {
                    conn.line.setStyle({
                        color: lineUpgrades.colors[next],
                        weight: lineUpgrades.weights[next]
                    });
                });

                updateUpgradeButtons();
                updateIncomeRate();
                showWarning(`Лінії покращено до рівня "${lineUpgrades.levels[next]}"`, true);

                // Ефект апгрейду на всіх лініях
                lineLayers.forEach(conn => {
                    const midPoint = [(conn.line.getLatLngs()[0].lat + conn.line.getLatLngs()[1].lat) / 2,
                    (conn.line.getLatLngs()[0].lng + conn.line.getLatLngs()[1].lng) / 2];
                    createUpgradeEffect(midPoint);
                });
            } else {
                showWarning(`Недостатньо ресурсів! Потрібно ${cost} МВт·год`, false);
            }
        }

        function createTooltipContent(name, powerInfo) {
            if (powerStationMarkers[name]) {
                const ps = powerStationMarkers[name];
                return `<b>${name} (${ps.type})</b><div class="power-info">Потужність: ${ps.powerOutput} МВт</div>`;
            }
            return `<b>${name}</b><div class="power-info">${powerInfo}</div>`;
        }

        function updatePowerStationTooltip(stationName) {
            const ps = powerStationMarkers[stationName];
            if (!ps) return;

            const newContent = createTooltipContent(
                stationName,
                `Потужність: ${ps.powerOutput} МВт`
            );

            const tooltip = ps.marker.getTooltip();
            if (tooltip && tooltip.isOpen()) {
                ps.marker.setTooltipContent(newContent);
            }

            ps.marker.unbindTooltip();
            ps.marker.bindTooltip(newContent, {
                permanent: false,
                direction: 'top'
            });
        }

        function blinkPowerStation(stationName) {
            const ps = powerStationMarkers[stationName];
            if (!ps) return;

            updatePowerStationTooltip(stationName);
            createUpgradeEffect(ps.marker.getLatLng());
            createParticleEffect(ps.marker.getLatLng(), 'upgrade');

            let blinkCount = 0;
            const maxBlinks = 6;
            const blinkInterval = 200;

            const blinkIntervalId = setInterval(() => {
                if (blinkCount >= maxBlinks) {
                    clearInterval(blinkIntervalId);
                    updatePowerStationVisual(stationName, ps.damaged);
                    return;
                }

                if (blinkCount % 2 === 0) {
                    ps.marker.getElement().style.background = 'radial-gradient(circle, #ffeb3b 0%, #fbc02d 100%)';
                } else {
                    updatePowerStationVisual(stationName, ps.damaged);
                    ps.marker.getElement().style.background = '';
                }

                blinkCount++;
            }, blinkInterval);
        }

        function buyAutoRepair() {
            if (!lineUpgrades.autoRepair.unlocked) {
                if (energyResources >= lineUpgrades.autoRepair.cost) {
                    energyResources -= lineUpgrades.autoRepair.cost;
                    lineUpgrades.autoRepair.unlocked = true;
                    lineUpgrades.autoRepair.active = true;
                    updateResourceUI();
                    updateUpgradeButtons();
                    startAutoRepair();
                    showWarning("Автоматичний ремонт активовано та увімкнено!", true);
                } else {
                    showWarning(`Недостатньо ресурсів! Потрібно ${lineUpgrades.autoRepair.cost} МВт·год`, false);
                }
            }
            else {
                lineUpgrades.autoRepair.active = !lineUpgrades.autoRepair.active;
                updateUpgradeButtons();
                if (lineUpgrades.autoRepair.active) {
                    startAutoRepair();
                    showWarning("Автоматичний ремонт увімкнено!", true);
                } else {
                    clearAllAutoRepairs();
                    showWarning("Автоматичний ремонт вимкнено!", false);
                }
            }
        }

        function startAutoRepair() {
            if (!lineUpgrades.autoRepair.unlocked || !lineUpgrades.autoRepair.active) return;

            const damagedLines = lineLayers.filter(line => line.damaged);

            if (repairTeams > 0 && damagedLines.length > 0) {
                const lineToRepair = damagedLines[0];
                repairTeams--;
                updateTeamStatus();

                const repairTime = repairTimes['line'] * lineUpgrades.autoRepair.repairSpeed *
                    lineUpgrades.repairTimes[lineUpgrades.level];

                showProgressBar(lineToRepair.damageMarker.getLatLng(), repairTime, () => {
                    repairLine(lineToRepair);
                    repairTeams++;
                    updateTeamStatus();
                    setTimeout(startAutoRepair, 0);
                });
            }
        }

        function clearAllAutoRepairs() {
            lineLayers.forEach(line => {
                if (line.repairTimer) {
                    clearTimeout(line.repairTimer);
                    line.repairTimer = null;
                }
            });
        }

        function updateUpgradeButtons() {
            const lineBtn = document.getElementById('lineUpgradeBtn');
            const lvl = lineUpgrades.level;
            const next = lvl + 1;

            if (next <= lineUpgrades.maxLevel) {
                const cost = lineUpgrades.costs[next];
                lineBtn.querySelector('.upgrade-cost').textContent = `${cost} МВт·год`;
                lineBtn.querySelector('.upgrade-effect').innerHTML = `
            <span style="color:#81C784">${lineUpgrades.levels[next]}</span><br>
            Шанс пошкодження: <b>${Math.round(lineUpgrades.damageChances[next] * 100)}%</b><br>
            Час ремонту: <b>${Math.round((1 - lineUpgrades.repairTimes[next]) * 100)}% швидше</b>
        `;
                lineBtn.disabled = energyResources < cost;
            } else {
                lineBtn.querySelector('.upgrade-effect').innerHTML = `
            <span style="color:#FFD700">${lineUpgrades.levels[lvl]} (макс)</span>
        `;
                lineBtn.disabled = true;
            }

            const autoRepairBtn = document.getElementById('autoRepairBtn');
            if (!lineUpgrades.autoRepair.unlocked) {
                autoRepairBtn.querySelector('.upgrade-cost').textContent = `${lineUpgrades.autoRepair.cost} МВт·год`;
                autoRepairBtn.disabled = energyResources < lineUpgrades.autoRepair.cost;
            } else {
                autoRepairBtn.querySelector('.upgrade-title').innerHTML = lineUpgrades.autoRepair.active ?
                    '<span style="color:#EF5350">Вимкнути автοремонт</span>' :
                    '<span style="color:#66BB6A">Увімкнути автοремонт</span>';
                autoRepairBtn.querySelector('.upgrade-icon').textContent = lineUpgrades.autoRepair.active ? '⛔️' : '▶️';
                autoRepairBtn.disabled = false;
            }

            document.querySelectorAll('.upgrade-btn').forEach(btn => {
                if (!btn.id || (btn.id !== 'lineUpgradeBtn' && btn.id !== 'autoRepairBtn')) {
                    const cost = parseInt(btn.querySelector('.upgrade-cost').textContent);
                    btn.disabled = energyResources < cost;
                }
            });
        }

        function buildGraph() {
            const graph = {};
            Object.keys(cities).forEach(name => graph[name] = []);
            Object.keys(powerStationMarkers).forEach(name => graph[name] = []);

            for (const { from, to, damaged } of lineLayers) {
                if (!damaged) {
                    graph[from].push(to);
                    graph[to].push(from);
                }
            }
            return graph;
        }

        function showWarning(message, isGoodNews = false) {
            const warning = document.createElement('div');
            warning.className = `warning-message ${isGoodNews ? 'good-news' : 'bad-news'}`;
            warning.textContent = message;
            document.body.appendChild(warning);
            setTimeout(() => warning.remove(), 4000);
        }

        function updateCityHealthIndicator(cityName, show) {
            if (show) {
                if (!cityHealthMarkers[cityName]) {
                    const container = L.DomUtil.create('div', 'health-container');
                    L.DomUtil.create('div', 'health-bar', container);

                    const icon = L.divIcon({
                        className: '',
                        html: container.outerHTML,
                        iconSize: [60, 6],
                        iconAnchor: [30, 0]
                    });

                    const marker = L.marker(cities[cityName].coords, {
                        icon,
                        zIndexOffset: 1000
                    }).addTo(map);

                    cityHealthMarkers[cityName] = {
                        marker
                    };

                    setTimeout(() => updateHealthBar(cityName, cityHealth[cityName].current), 0);
                } else {
                    cityHealthMarkers[cityName].marker.setOpacity(1);
                }
            } else if (cityHealthMarkers[cityName]) {
                cityHealthMarkers[cityName].marker.setOpacity(0);
            }
        }

        function updateHealthBar(cityName, percentage) {
            const healthMarker = cityHealthMarkers[cityName];
            if (healthMarker) {
                const el = healthMarker.marker.getElement();
                if (el) {
                    const bar = el.querySelector('.health-bar');
                    if (bar) {
                        bar.style.width = `${percentage}%`;
                    }
                }
            }
        }

        function startHealthDecrease(cityName) {
            if (cityHealth[cityName].timer) return;

            cityHealth[cityName].current = 100;
            updateHealthBar(cityName, 100);

            const decreaseInterval = 100;
            const totalTime = 60000;
            const steps = totalTime / decreaseInterval;
            const decreasePerStep = 100 / steps;

            cityHealth[cityName].timer = setInterval(() => {
                cityHealth[cityName].current = Math.max(0, cityHealth[cityName].current - decreasePerStep);
                updateHealthBar(cityName, cityHealth[cityName].current);

                if (cityHealth[cityName].current <= 0) {
                    clearInterval(cityHealth[cityName].timer);
                    cityHealth[cityName].timer = null;
                    disableCity(cityName);
                    showWarning(`${cityName} втратив всі ресурси!`, false);
                }
            }, decreaseInterval);
        }

        function disableCity(cityName) {
            const marker = cityMarkers[cityName];

            if (cityHealthMarkers[cityName]) {
                cityHealthMarkers[cityName].marker.setOpacity(0);
            }

            // Оновлюємо клас маркера
            updateCityVisual(cityName, 'city-marker disabled');
            loseLife();
        }

        function enableCity(cityName) {
            const marker = cityMarkers[cityName];

            if (cityDisabledLayers[cityName]) {
                map.removeLayer(cityDisabledLayers[cityName]);
                delete cityDisabledLayers[cityName];
            }

            updateCityVisual(cityName, 'city-marker powered');
        }

        function stopHealthDecrease(cityName) {
            if (cityHealth[cityName].timer) {
                clearInterval(cityHealth[cityName].timer);
                cityHealth[cityName].timer = null;
            }
        }

        function resetCityHealth(cityName) {
            cityHealth[cityName].current = 100;
            updateHealthBar(cityName, 100);
            enableCity(cityName);
        }

        // Створення міст з покращеними іконками
        for (const [name, data] of Object.entries(cities)) {
            const container = L.DomUtil.create('div', 'city-marker powered');
            container.style.width = '12px';
            container.style.height = '12px';

            const marker = L.marker(data.coords, {
                icon: L.divIcon({
                    className: '',
                    html: container.outerHTML,
                    iconSize: [12, 12],
                    iconAnchor: [6, 6]
                }),
                zIndexOffset: 1000
            }).addTo(map);

            marker.bindTooltip(createTooltipContent(name, `Потреба: ${data.powerNeed} МВт`), {
                permanent: false,
                direction: 'top'
            });

            cityMarkers[name] = marker;
            cityHealth[name] = { current: 100, timer: null, powered: true };
        }

        function showProgressBar(latlng, duration, onComplete) {
            const container = L.DomUtil.create('div', 'progress-container');
            const progressBar = L.DomUtil.create('div', 'progress-bar', container);

            const icon = L.divIcon({
                className: '',
                html: container.outerHTML,
                iconSize: [60, 8],
                iconAnchor: [30, 0]
            });

            const marker = L.marker(latlng, { icon }).addTo(map);

            let start = null;
            function animate(timestamp) {
                if (!start) start = timestamp;
                const progress = (timestamp - start) / duration;

                const el = marker.getElement();
                if (el) {
                    const barEl = el.querySelector('.progress-bar');
                    if (barEl) {
                        barEl.style.width = `${Math.min(progress * 100, 100)}%`;
                    }
                }

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    map.removeLayer(marker);
                    onComplete();
                }
            }

            requestAnimationFrame(animate);
        }

        // Створення електростанцій з покращеними іконками
        powerStations.forEach((station) => {
            const container = L.DomUtil.create('div', getStationClass(station.type));
            container.style.width = '20px';
            container.style.height = '20px';

            const iconElement = L.DomUtil.create('div', 'station-icon', container);
            iconElement.innerHTML = getStationIcon(station.type);

            const marker = L.marker(station.coords, {
                icon: L.divIcon({
                    className: '',
                    html: container.outerHTML,
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                }),
                zIndexOffset: 2000
            }).addTo(map);

            marker.bindTooltip(createTooltipContent(
                `${station.name} (${station.type})`,
                `Потужність: ${station.powerOutput} МВт`
            ), { permanent: false, direction: 'top' });

            powerStationMarkers[station.name] = {
                marker,
                fire: null,
                damaged: false,
                type: station.type,
                powerOutput: station.powerOutput
            };

            marker.on('click', () => {
                repairPowerStation(station.name);
                updatePowerStationTooltip(station.name);
            });
        });

        function repairPowerStation(name) {
            const ps = powerStationMarkers[name];
            if (!ps.damaged) return;

            if (repairTeams <= 0) {
                showWarning("Недостатньо бригад! Зачекайте, поки звільниться хоча б одна.", false);
                return;
            }

            repairTeams--;
            updateTeamStatus();

            showProgressBar(ps.marker.getLatLng(), repairTimes[ps.type] * difficultyMultiplier, () => {
                ps.damaged = false;
                if (ps.fire) {
                    map.removeLayer(ps.fire);
                    ps.fire = null;
                }

                // Оновлюємо клас елемента
                updatePowerStationVisual(name, false);

                // Ефекти ремонту
                createRepairEffect(ps.marker.getLatLng());
                createParticleEffect(ps.marker.getLatLng(), 'repair');

                repairTeams++;
                updateTeamStatus();
                updateCityPowerStatus();
                updateIncomeRate();
            });
        }

        function repairLine(line) {
            if (!line.damaged) return;

            line.damaged = false;
            line.line.setStyle({
                color: lineUpgrades.colors[lineUpgrades.level],
                weight: lineUpgrades.weights[lineUpgrades.level]
            });
            line.damageMarker.setOpacity(0);

            // Ефекти ремонту
            createRepairEffect(line.damageMarker.getLatLng());
            createParticleEffect(line.damageMarker.getLatLng(), 'repair');

            if (line.repairTimer) {
                clearTimeout(line.repairTimer);
                line.repairTimer = null;
            }

            updateCityPowerStatus();
            updateIncomeRate();
        }

        function midpoint(coord1, coord2) {
            return [(coord1[0] + coord2[0]) / 2, (coord1[1] + coord2[1]) / 2];
        }

        function hasPath(graph, start, goal) {
            if (start === goal) return true;
            const visited = new Set();
            const queue = [start];
            while (queue.length) {
                const node = queue.shift();
                if (node === goal) return true;
                visited.add(node);
                for (const neighbor of graph[node] || []) {
                    if (!visited.has(neighbor)) queue.push(neighbor);
                }
            }
            return false;
        }

        function updateTeamStatus() {
            const teamElement = document.createElement('div');
            teamElement.id = 'teamsStatus';
            teamElement.innerHTML = `Ремонтні бригади: <span style="color:${repairTeams > 0 ? 'green' : 'red'}">${repairTeams}</span>`;

            const statusPanel = document.getElementById('statusPanel');
            const existingTeamElement = document.getElementById('teamsStatus');

            if (existingTeamElement) {
                statusPanel.replaceChild(teamElement, existingTeamElement);
            } else {
                statusPanel.appendChild(teamElement);
            }
        }

        function calculatePowerDistribution() {
            const graph = buildGraph();

            const workingStations = Object.entries(powerStationMarkers)
                .filter(([_, ps]) => !ps.damaged)
                .map(([name, ps]) => ({
                    name,
                    powerOutput: ps.powerOutput,
                    remainingPower: ps.powerOutput,
                    cities: []
                }));

            workingStations.sort((a, b) => b.powerOutput - a.powerOutput);

            const result = {};
            const poweredCities = new Set();

            for (const station of workingStations) {
                const reachableCities = Object.keys(cities).filter(city =>
                    !poweredCities.has(city) && hasPath(graph, city, station.name)
                );

                reachableCities.sort((a, b) => {
                    const distA = getDistance(cities[a].coords, powerStationMarkers[station.name].marker.getLatLng());
                    const distB = getDistance(cities[b].coords, powerStationMarkers[station.name].marker.getLatLng());
                    return distA - distB;
                });

                for (const city of reachableCities) {
                    if (station.remainingPower >= cities[city].powerNeed) {
                        station.cities.push(city);
                        station.remainingPower -= cities[city].powerNeed;
                        poweredCities.add(city);
                        result[city] = true;
                    }
                }
            }

            const totalProduction = workingStations.reduce((sum, s) => sum + s.powerOutput, 0);
            const totalConsumption = Object.values(cities).reduce((sum, c) => sum + c.powerNeed, 0);
            const poweredConsumption = workingStations.reduce((sum, s) => sum + (s.powerOutput - s.remainingPower), 0);

            return {
                distribution: result,
                stats: { totalProduction, totalConsumption, poweredConsumption }
            };
        }

        function getDistance(latLng1, latLng2) {
            const R = 6371;
            const dLat = (latLng2.lat - latLng1[0]) * Math.PI / 180;
            const dLon = (latLng2.lng - latLng1[1]) * Math.PI / 180;
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(latLng1[0] * Math.PI / 180) * Math.cos(latLng2.lat * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        function updateStatusPanel(poweredCities, totalCities, stats) {
            const psStats = { 'ГЕС': [0, 0], 'АЕС': [0, 0], 'ТЕС': [0, 0], 'ВЕС': [0, 0] };
            for (const { name, type } of powerStations) {
                const ps = powerStationMarkers[name];
                if (ps.damaged) psStats[type][1]++;
                else psStats[type][0]++;
            }

            let workingLines = 0, damagedLines = 0;
            for (const conn of lineLayers) {
                if (conn.damaged) damagedLines++;
                else workingLines++;
            }

            const color = (good, total) => {
                const damaged = total - good;
                return `<span style="color:red;">${damaged}</span> / <span style="color:green;">${total}</span>`;
            };

            const deficit = Math.round(stats.poweredConsumption - stats.totalConsumption);

            const statusHTML = `
  <div><strong>Міста зі світлом:</strong> ${poweredCities} з ${totalCities}</div>
  <div><strong>ГЕС:</strong> ${color(psStats['ГЕС'][0], psStats['ГЕС'][0] + psStats['ГЕС'][1])}</div>
  <div><strong>АЕС:</strong> ${color(psStats['АЕС'][0], psStats['АЕС'][0] + psStats['АЕС'][1])}</div>
  <div><strong>ТЕС:</strong> ${color(psStats['ТЕС'][0], psStats['ТЕС'][0] + psStats['ТЕС'][1])}</div>
  <div><strong>ВЕС:</strong> ${color(psStats['ВЕС'][0], psStats['ВЕС'][0] + psStats['ВЕС'][1])}</div>
  <div><strong>Лінії:</strong> ${color(workingLines, workingLines + damagedLines)}</div>
  <div><strong>Виробництво:</strong> ${Math.round(stats.totalProduction)} МВт</div>
  <div><strong>Споживання:</strong> ${Math.round(stats.totalConsumption)} МВт</div>
  <div><strong>Дефіцит(для міст):</strong> ${deficit} МВт</div>
  <div id="teamsStatus"></div>
`;

            document.getElementById('statusPanel').innerHTML = statusHTML;
            updateTeamStatus();
        }

        function updateResourceUI() {
            document.getElementById("energyResources").textContent = Math.floor(energyResources);
        }

        function buyUpgrade(type) {
            const upgrade = upgrades[type];
            if (energyResources >= upgrade.cost) {
                energyResources -= upgrade.cost;
                updateResourceUI();

                const result = upgrade.effect();

                if (type === 'powerPlant' && result) {
                    const ps = powerStationMarkers[result];
                    showWarning(`${ps.type} "${result}" покращено! +200 МВт`, true);
                    blinkPowerStation(result);
                } else {
                    showWarning(`Апгрейд "${type}" куплено! Витрачено ${upgrade.cost} МВт·год`, true);
                }

                updateCityPowerStatus();
                updateIncomeRate();
            } else {
                showWarning(`Недостатньо ресурсів! Потрібно ${upgrade.cost} МВт·год`, false);
            }
        }

        function updateCityPowerStatus() {
            const { distribution, stats } = calculatePowerDistribution();
            updateIncomeRate();

            for (const [city, marker] of Object.entries(cityMarkers)) {
                const powered = distribution[city] || false;
                const wasPowered = cityHealth[city].powered;
                cityHealth[city].powered = powered;

                if (wasPowered !== powered) {
                    if (powered) {
                        stopHealthDecrease(city);
                        resetCityHealth(city);
                        updateCityHealthIndicator(city, false);
                        updateCityVisual(city, 'city-marker powered');
                    } else {
                        resetCityHealth(city);
                        updateCityHealthIndicator(city, true);
                        startHealthDecrease(city);
                        updateCityVisual(city, 'city-marker unpowered');
                    }
                }
            }

            const poweredCount = Object.values(distribution).filter(v => v).length;
            updateStatusPanel(poweredCount, Object.keys(cityMarkers).length, stats);
            updateIncomeRate();
        }

        // Створення з'єднань з покращеними лініями
        connections.forEach(([from, to]) => {
            const latlngs = [
                cities[from]?.coords || powerStations.find(p => p.name === from)?.coords,
                cities[to]?.coords || powerStations.find(p => p.name === to)?.coords
            ];

            const line = L.polyline(latlngs, {
                color: lineUpgrades.colors[lineUpgrades.level],
                weight: lineUpgrades.weights[lineUpgrades.level],
                className: 'power-line'
            }).addTo(map).bringToBack();

            const damageIcon = L.DomUtil.create('div', '');
            damageIcon.innerHTML = '<span style="font-size:24px;line-height:24px;color:#ff5722;text-shadow:0 0 8px #ff5722;">⚡</span>';

            const damageMarker = L.marker(midpoint(latlngs[0], latlngs[1]), {
                icon: L.divIcon({
                    className: '',
                    html: damageIcon.outerHTML,
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                }),
                zIndexOffset: 0
            }).addTo(map).setOpacity(0);

            const conn = {
                from,
                to,
                line,
                damaged: false,
                damageMarker,
                repairTimer: null
            };
            lineLayers.push(conn);

            damageMarker.on('click', () => {
                if (!conn.damaged || repairTeams <= 0) return;

                if (lineUpgrades.autoRepair.unlocked && conn.repairTimer) {
                    showWarning("Автоматичний ремонт вже виконує цю роботу!", false);
                    return;
                }

                repairTeams--;
                updateTeamStatus();

                if (conn.repairTimer) {
                    clearTimeout(conn.repairTimer);
                    conn.repairTimer = null;
                }

                const repairTime = repairTimes['line'] * difficultyMultiplier *
                    lineUpgrades.repairTimes[lineUpgrades.level];

                showProgressBar(damageMarker.getLatLng(), repairTime, () => {
                    repairLine(conn);
                    repairTeams++;
                    updateTeamStatus();

                    if (lineUpgrades.autoRepair.unlocked) {
                        startAutoRepair();
                    }
                });
            });
        });

        function simulateAttack() {
            if (!isGameRunning) return;

            let attackExecuted = false;
            const now = Date.now();

            if (Math.random() < 0.7) {
                const workingLines = lineLayers.filter(line => !line.damaged);
                if (workingLines.length > 0) {
                    const randomLine = workingLines[Math.floor(Math.random() * workingLines.length)];

                    const dmgChance = lineUpgrades.damageChances[lineUpgrades.level];
                    if (Math.random() < dmgChance) {
                        randomLine.damaged = true;
                        randomLine.line.setStyle({
                            color: '#ff0000',
                            className: 'power-line damaged'
                        });
                        randomLine.damageMarker.setOpacity(1);
                        attackExecuted = true;

                        // Ефект атаки
                        createLightningEffect(randomLine.damageMarker.getLatLng());
                        createParticleEffect(randomLine.damageMarker.getLatLng(), 'damage');

                        if (lineUpgrades.autoRepair.unlocked && lineUpgrades.autoRepair.active) {
                            if (repairTeams > 0 && !randomLine.repairInProgress) {
                                randomLine.repairInProgress = true;
                                repairTeams--;
                                updateTeamStatus();

                                const repairTime = repairTimes['line'] *
                                    lineUpgrades.autoRepair.repairSpeed *
                                    lineUpgrades.repairTimes[lineUpgrades.level];

                                showProgressBar(
                                    randomLine.damageMarker.getLatLng(),
                                    repairTime,
                                    () => {
                                        if (randomLine.damaged) {
                                            repairLine(randomLine);
                                        }
                                        randomLine.repairInProgress = false;
                                        repairTeams++;
                                        updateTeamStatus();
                                    }
                                );
                            } else if (repairTeams <= 0) {
                                randomLine.repairTimer = setTimeout(() => {
                                    if (randomLine.damaged && lineUpgrades.autoRepair.active) {
                                        repairLine(randomLine);
                                    }
                                }, 2000);
                            }
                        }
                    } else {
                        showWarning("Атака відбита! Міцні лінії витримали удар.", true);
                    }
                }
            }

            if (!attackExecuted && Math.random() < 0.3) {
                const workingStations = Object.values(powerStationMarkers)
                    .filter(ps => !ps.damaged && ps.type === 'ТЕС');

                if (workingStations.length > 0) {
                    const randomStation = workingStations[Math.floor(Math.random() * workingStations.length)];
                    randomStation.damaged = true;

                    // Створення ефекту пожежі
                    const fireContainer = L.DomUtil.create('div', '');
                    fireContainer.innerHTML = '<span style="font-size:20px;line-height:20px;color:#ff5722;text-shadow:0 0 10px #ff5722;">🔥</span>';

                    randomStation.fire = L.marker(randomStation.marker.getLatLng(), {
                        icon: L.divIcon({
                            className: '',
                            html: fireContainer.outerHTML,
                            iconSize: [20, 20],
                            iconAnchor: [10, 20]
                        }),
                        zIndexOffset: 2001
                    }).addTo(map);

                    // Оновлення класу станції
                    const stationName = Object.keys(powerStationMarkers).find(name => powerStationMarkers[name] === randomStation);
                    updatePowerStationVisual(stationName, true);

                    // Ефекти атаки
                    createLightningEffect(randomStation.marker.getLatLng());
                    createParticleEffect(randomStation.marker.getLatLng(), 'damage');

                    attackExecuted = true;
                }
            }

            if (attackExecuted) {
                updateCityPowerStatus();

                if (lineUpgrades.autoRepair.unlocked && lineUpgrades.autoRepair.active) {
                    setTimeout(() => {
                        const damagedLines = lineLayers.filter(line =>
                            line.damaged &&
                            !line.repairInProgress &&
                            !line.repairTimer
                        );

                        if (damagedLines.length > 0 && repairTeams > 0) {
                            const lineToRepair = damagedLines[0];
                            lineToRepair.repairInProgress = true;
                            repairTeams--;
                            updateTeamStatus();

                            const repairTime = repairTimes['line'] *
                                lineUpgrades.autoRepair.repairSpeed *
                                lineUpgrades.repairTimes[lineUpgrades.level];

                            showProgressBar(
                                lineToRepair.damageMarker.getLatLng(),
                                repairTime,
                                () => {
                                    repairLine(lineToRepair);
                                    lineToRepair.repairInProgress = false;
                                    repairTeams++;
                                    updateTeamStatus();
                                }
                            );
                        }
                    }, 1500);
                }
            }

            difficultyMultiplier = Math.min(2, 0.7 + (now - gameStartTime) / 1800000);
            scheduleNextAttack();
        }

        function scheduleNextAttack() {
            const now = Date.now();
            const timeSinceLast = now - lastAttackTime;
            const timeSinceStart = (now - gameStartTime) / 60000;

            if (timeSinceStart < 0.083) {
                setTimeout(() => {
                    simulateAttack();
                    lastAttackTime = Date.now();
                }, 2000);
                return;
            }

            const baseDelay = Math.max(5000, 15000 - timeSinceStart * 300);
            const dynamicDelay = Math.min(20000, Math.max(3000, baseDelay));

            setTimeout(() => {
                simulateAttack();
                lastAttackTime = Date.now();
                difficultyMultiplier = Math.min(2, 0.7 + timeSinceStart / 30);
            }, dynamicDelay);
        }

        function updateLivesDisplay() {
            const lifeElements = document.querySelectorAll('.life');
            lifeElements.forEach((el, index) => {
                el.style.display = index < lives ? 'inline-block' : 'none';
            });
        }

        function loseLife() {
            if (isGameOver) return;

            lives--;
            updateLivesDisplay();

            if (lives <= 0) {
                endGame();
            } else {
                showWarning("Ви втратили одне життя!", false);
            }
        }

        function endGame() {
            isGameOver = true;
            document.getElementById('game-over').style.display = 'flex';
            clearInterval(balanceUpdateInterval);
            clearTimeout(attackTimeout);
        }

        function restartGame() {
            document.getElementById('game-over').style.opacity = '0';
            setTimeout(() => location.reload(), 500);
        }

        document.getElementById('restart-button').addEventListener('click', restartGame);

        document.getElementById('toggleUpgradesPanel').addEventListener('click', function () {
            const panel = document.getElementById('upgradesPanel');
            panel.classList.toggle('collapsed');
            this.textContent = panel.classList.contains('collapsed') ? '⚙️' : '✕';
            this.style.right = panel.classList.contains('collapsed') ? '10px' : '320px';
        });

        document.getElementById('toggleStatusPanel').addEventListener('click', function () {
            const panel = document.getElementById('statusPanel');
            panel.classList.toggle('collapsed');
            this.textContent = panel.classList.contains('collapsed') ? 'ℹ️' : '✕';
            this.style.left = panel.classList.contains('collapsed') ? '10px' : '320px';
        });

        // Ініціалізація при завантаженні
        document.addEventListener('DOMContentLoaded', function () {
            const upgradesPanel = document.getElementById('upgradesPanel');
            const statusPanel = document.getElementById('statusPanel');
            const toggleUpgrades = document.getElementById('toggleUpgradesPanel');
            const toggleStatus = document.getElementById('toggleStatusPanel');

            // Початковий стан - схований
            upgradesPanel.classList.add('collapsed');
            statusPanel.classList.add('collapsed');

            // Позиціонуємо кнопки
            toggleUpgrades.style.right = '10px';
            toggleStatus.style.left = '10px';

            // Інші ініціалізації...
            updateTeamStatus();
            updateCityPowerStatus();
            updateUpgradeButtons();
            updateIncomeRate();
            balanceUpdateInterval = setInterval(updateBalancePeriodically, 1000);
            scheduleNextAttack();
            updateLivesDisplay();
        });
    </script>
</body>

</html>
